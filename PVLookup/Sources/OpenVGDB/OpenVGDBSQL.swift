// Autocreated by sqlite2swift at 2024-10-20T18:24:10Z

import SQLite3
import Foundation
import Lighter

/**
 * A structure representing a SQLite database.
 * 
 * ### Database Schema
 * 
 * The schema captures the SQLite table/view catalog as safe Swift types.
 * 
 * #### Tables
 * 
 * - ``REGIONS``  (SQL: `REGIONS`)
 * - ``RELEASES`` (SQL: `RELEASES`)
 * - ``ROMs``     (SQL: `ROMs`)
 * - ``SYSTEMS``  (SQL: `SYSTEMS`)
 * 
 * > Hint: Use [SQL Views](https://www.sqlite.org/lang_createview.html)
 * >       to create Swift types that represent common queries.
 * >       (E.g. joins between tables or fragments of table data.)
 * 
 * ### Examples
 * 
 * Perform record operations on ``REGIONS`` records:
 * ```swift
 * let records = try await db.rEGIONS.filter(orderBy: \.regionName) {
 *   $0.regionName != nil
 * }
 * ```
 * 
 * Perform column selects on the `REGIONS` table:
 * ```swift
 * let values = try await db.select(from: \.rEGIONS, \.regionName) {
 *   $0.in([ 2, 3 ])
 * }
 * ```
 */
@dynamicMemberLookup
public struct OpenvgdbSchema : SQLDatabase, SQLDatabaseAsyncFetchOperations {
  
  /**
   * Mappings of table/view Swift types to their "reference name".
   * 
   * The `RecordTypes` structure contains a variable for the Swift type
   * associated each table/view of the database. It maps the tables
   * "reference names" (e.g. ``rEGIONS``) to the
   * "record type" of the table (e.g. ``REGIONS``.self).
   */
  public struct RecordTypes : Swift.Sendable {
    
    /// Returns the REGIONS type information (SQL: `REGIONS`).
    public let rEGIONS = REGIONS.self
    
    /// Returns the RELEASES type information (SQL: `RELEASES`).
    public let rELEASES = RELEASES.self
    
    /// Returns the ROMs type information (SQL: `ROMs`).
    public let rOMs = ROMs.self
    
    /// Returns the SYSTEMS type information (SQL: `SYSTEMS`).
    public let sYSTEMS = SYSTEMS.self
  }
  
  /**
   * Record representing the `REGIONS` SQL table.
   * 
   * Record types represent rows within tables&views in a SQLite database.
   * They are returned by the functions or queries/filters generated by
   * Enlighter.
   * 
   * ### Examples
   * 
   * Perform record operations on ``REGIONS`` records:
   * ```swift
   * let records = try await db.rEGIONS.filter(orderBy: \.regionName) {
   *   $0.regionName != nil
   * }
   * ```
   * 
   * Perform column selects on the `REGIONS` table:
   * ```swift
   * let values = try await db.select(from: \.rEGIONS, \.regionName) {
   *   $0.in([ 2, 3 ])
   * }
   * ```
   * 
   * ### SQL
   * 
   * The SQL used to create the table associated with the record:
   * ```sql
   * CREATE TABLE "REGIONS" (
   * "regionID" INTEGER PRIMARY KEY AUTOINCREMENT,
   * "regionName" TEXT
   * )
   * ```
   */
  public struct REGIONS : Identifiable, SQLKeyedTableRecord, Codable, Sendable {
    
    /// Static SQL type information for the ``REGIONS`` record.
    public static let schema = Schema()
    
    /// Primary key `regionID` (`INTEGER`), optional (default: `nil`).
    public var id : Int?
    
    /// Column `regionName` (`TEXT`), optional (default: `nil`).
    public var regionName : String?
    
    /**
     * Initialize a new ``REGIONS`` record.
     * 
     * - Parameters:
     *   - id: Primary key `regionID` (`INTEGER`), optional (default: `nil`).
     *   - regionName: Column `regionName` (`TEXT`), optional (default: `nil`).
     */
    @inlinable
    public init(id: Int? = nil, regionName: String? = nil)
    {
      self.id = id
      self.regionName = regionName
    }
  }
  
  /**
   * Record representing the `RELEASES` SQL table.
   * 
   * Record types represent rows within tables&views in a SQLite database.
   * They are returned by the functions or queries/filters generated by
   * Enlighter.
   * 
   * ### Examples
   * 
   * Perform record operations on ``RELEASES`` records:
   * ```swift
   * let records = try await db.rELEASES.filter(orderBy: \.releaseTitleName) {
   *   $0.releaseTitleName != nil
   * }
   * ```
   * 
   * Perform column selects on the `RELEASES` table:
   * ```swift
   * let values = try await db.select(from: \.rELEASES, \.releaseTitleName) {
   *   $0.in([ 2, 3 ])
   * }
   * ```
   * 
   * ### SQL
   * 
   * The SQL used to create the table associated with the record:
   * ```sql
   * CREATE TABLE "RELEASES" (
   * "releaseID" INTEGER PRIMARY KEY AUTOINCREMENT,
   * "romID" INTEGER,
   * "releaseTitleName" TEXT,
   * "regionLocalizedID" INTEGER,
   * "TEMPregionLocalizedName" TEXT,
   * "TEMPsystemShortName" TEXT,
   * "TEMPsystemName" TEXT,
   * "releaseCoverFront" TEXT,
   * "releaseCoverBack" TEXT,
   * "releaseCoverCart" TEXT,
   * "releaseCoverDisc" TEXT,
   * "releaseDescription" TEXT,
   * "releaseDeveloper" TEXT,
   * "releasePublisher" TEXT,
   * "releaseGenre" TEXT,
   * "releaseDate" TEXT,
   * "releaseReferenceURL" TEXT,
   * "releaseReferenceImageURL" TEXT
   * )
   * ```
   */
  public struct RELEASES : Identifiable, SQLKeyedTableRecord, Codable, Sendable {
    
    /// Static SQL type information for the ``RELEASES`` record.
    public static let schema = Schema()
    
    /// Primary key `releaseID` (`INTEGER`), optional (default: `nil`).
    public var id : Int?
    
    /// Column `romID` (`INTEGER`), optional (default: `nil`).
    public var romID : Int?
    
    /// Column `releaseTitleName` (`TEXT`), optional (default: `nil`).
    public var releaseTitleName : String?
    
    /// Column `regionLocalizedID` (`INTEGER`), optional (default: `nil`).
    public var regionLocalizedID : Int?
    
    /// Column `TEMPregionLocalizedName` (`TEXT`), optional (default: `nil`).
    public var tEMPregionLocalizedName : String?
    
    /// Column `TEMPsystemShortName` (`TEXT`), optional (default: `nil`).
    public var tEMPsystemShortName : String?
    
    /// Column `TEMPsystemName` (`TEXT`), optional (default: `nil`).
    public var tEMPsystemName : String?
    
    /// Column `releaseCoverFront` (`TEXT`), optional (default: `nil`).
    public var releaseCoverFront : String?
    
    /// Column `releaseCoverBack` (`TEXT`), optional (default: `nil`).
    public var releaseCoverBack : String?
    
    /// Column `releaseCoverCart` (`TEXT`), optional (default: `nil`).
    public var releaseCoverCart : String?
    
    /// Column `releaseCoverDisc` (`TEXT`), optional (default: `nil`).
    public var releaseCoverDisc : String?
    
    /// Column `releaseDescription` (`TEXT`), optional (default: `nil`).
    public var releaseDescription : String?
    
    /// Column `releaseDeveloper` (`TEXT`), optional (default: `nil`).
    public var releaseDeveloper : String?
    
    /// Column `releasePublisher` (`TEXT`), optional (default: `nil`).
    public var releasePublisher : String?
    
    /// Column `releaseGenre` (`TEXT`), optional (default: `nil`).
    public var releaseGenre : String?
    
    /// Column `releaseDate` (`TEXT`), optional (default: `nil`).
    public var releaseDate : String?
    
    /// Column `releaseReferenceURL` (`TEXT`), optional (default: `nil`).
    public var releaseReferenceURL : String?
    
    /// Column `releaseReferenceImageURL` (`TEXT`), optional (default: `nil`).
    public var releaseReferenceImageURL : String?
    
    /**
     * Initialize a new ``RELEASES`` record.
     * 
     * - Parameters:
     *   - id: Primary key `releaseID` (`INTEGER`), optional (default: `nil`).
     *   - romID: Column `romID` (`INTEGER`), optional (default: `nil`).
     *   - releaseTitleName: Column `releaseTitleName` (`TEXT`), optional (default: `nil`).
     *   - regionLocalizedID: Column `regionLocalizedID` (`INTEGER`), optional (default: `nil`).
     *   - tEMPregionLocalizedName: Column `TEMPregionLocalizedName` (`TEXT`), optional (default: `nil`).
     *   - tEMPsystemShortName: Column `TEMPsystemShortName` (`TEXT`), optional (default: `nil`).
     *   - tEMPsystemName: Column `TEMPsystemName` (`TEXT`), optional (default: `nil`).
     *   - releaseCoverFront: Column `releaseCoverFront` (`TEXT`), optional (default: `nil`).
     *   - releaseCoverBack: Column `releaseCoverBack` (`TEXT`), optional (default: `nil`).
     *   - releaseCoverCart: Column `releaseCoverCart` (`TEXT`), optional (default: `nil`).
     *   - releaseCoverDisc: Column `releaseCoverDisc` (`TEXT`), optional (default: `nil`).
     *   - releaseDescription: Column `releaseDescription` (`TEXT`), optional (default: `nil`).
     *   - releaseDeveloper: Column `releaseDeveloper` (`TEXT`), optional (default: `nil`).
     *   - releasePublisher: Column `releasePublisher` (`TEXT`), optional (default: `nil`).
     *   - releaseGenre: Column `releaseGenre` (`TEXT`), optional (default: `nil`).
     *   - releaseDate: Column `releaseDate` (`TEXT`), optional (default: `nil`).
     *   - releaseReferenceURL: Column `releaseReferenceURL` (`TEXT`), optional (default: `nil`).
     *   - releaseReferenceImageURL: Column `releaseReferenceImageURL` (`TEXT`), optional (default: `nil`).
     */
    @inlinable
    public init(
      id: Int? = nil,
      romID: Int? = nil,
      releaseTitleName: String? = nil,
      regionLocalizedID: Int? = nil,
      tEMPregionLocalizedName: String? = nil,
      tEMPsystemShortName: String? = nil,
      tEMPsystemName: String? = nil,
      releaseCoverFront: String? = nil,
      releaseCoverBack: String? = nil,
      releaseCoverCart: String? = nil,
      releaseCoverDisc: String? = nil,
      releaseDescription: String? = nil,
      releaseDeveloper: String? = nil,
      releasePublisher: String? = nil,
      releaseGenre: String? = nil,
      releaseDate: String? = nil,
      releaseReferenceURL: String? = nil,
      releaseReferenceImageURL: String? = nil
    )
    {
      self.id = id
      self.romID = romID
      self.releaseTitleName = releaseTitleName
      self.regionLocalizedID = regionLocalizedID
      self.tEMPregionLocalizedName = tEMPregionLocalizedName
      self.tEMPsystemShortName = tEMPsystemShortName
      self.tEMPsystemName = tEMPsystemName
      self.releaseCoverFront = releaseCoverFront
      self.releaseCoverBack = releaseCoverBack
      self.releaseCoverCart = releaseCoverCart
      self.releaseCoverDisc = releaseCoverDisc
      self.releaseDescription = releaseDescription
      self.releaseDeveloper = releaseDeveloper
      self.releasePublisher = releasePublisher
      self.releaseGenre = releaseGenre
      self.releaseDate = releaseDate
      self.releaseReferenceURL = releaseReferenceURL
      self.releaseReferenceImageURL = releaseReferenceImageURL
    }
  }
  
  /**
   * Record representing the `ROMs` SQL table.
   * 
   * Record types represent rows within tables&views in a SQLite database.
   * They are returned by the functions or queries/filters generated by
   * Enlighter.
   * 
   * ### Examples
   * 
   * Perform record operations on ``ROMs`` records:
   * ```swift
   * let records = try await db.rOMs.filter(orderBy: \.romHashCRC) {
   *   $0.romHashCRC != nil
   * }
   * ```
   * 
   * Perform column selects on the `ROMs` table:
   * ```swift
   * let values = try await db.select(from: \.rOMs, \.romHashCRC) {
   *   $0.in([ 2, 3 ])
   * }
   * ```
   * 
   * ### SQL
   * 
   * The SQL used to create the table associated with the record:
   * ```sql
   * CREATE TABLE "ROMs" (
   * "romID" INTEGER PRIMARY KEY AUTOINCREMENT,
   * "systemID" INTEGER,
   * "regionID" INTEGER,
   * "romHashCRC" TEXT,
   * "romHashMD5" TEXT,
   * "romHashSHA1" TEXT,
   * "romSize" INTEGER,
   * "romFileName" TEXT,
   * "romExtensionlessFileName" TEXT,
   * "romParent" TEXT,
   * "romSerial" TEXT,
   * "romHeader" TEXT,
   * "romLanguage" TEXT,
   * "TEMPromRegion" TEXT,
   * "romDumpSource" TEXT
   * )
   * ```
   */
  public struct ROMs : Identifiable, SQLKeyedTableRecord, Codable, Sendable {
    
    /// Static SQL type information for the ``ROMs`` record.
    public static let schema = Schema()
    
    /// Primary key `romID` (`INTEGER`), optional (default: `nil`).
    public var id : Int?
    
    /// Column `systemID` (`INTEGER`), optional (default: `nil`).
    public var systemID : Int?
    
    /// Column `regionID` (`INTEGER`), optional (default: `nil`).
    public var regionID : Int?
    
    /// Column `romHashCRC` (`TEXT`), optional (default: `nil`).
    public var romHashCRC : String?
    
    /// Column `romHashMD5` (`TEXT`), optional (default: `nil`).
    public var romHashMD5 : String?
    
    /// Column `romHashSHA1` (`TEXT`), optional (default: `nil`).
    public var romHashSHA1 : String?
    
    /// Column `romSize` (`INTEGER`), optional (default: `nil`).
    public var romSize : Int?
    
    /// Column `romFileName` (`TEXT`), optional (default: `nil`).
    public var romFileName : String?
    
    /// Column `romExtensionlessFileName` (`TEXT`), optional (default: `nil`).
    public var romExtensionlessFileName : String?
    
    /// Column `romParent` (`TEXT`), optional (default: `nil`).
    public var romParent : String?
    
    /// Column `romSerial` (`TEXT`), optional (default: `nil`).
    public var romSerial : String?
    
    /// Column `romHeader` (`TEXT`), optional (default: `nil`).
    public var romHeader : String?
    
    /// Column `romLanguage` (`TEXT`), optional (default: `nil`).
    public var romLanguage : String?
    
    /// Column `TEMPromRegion` (`TEXT`), optional (default: `nil`).
    public var tEMPromRegion : String?
    
    /// Column `romDumpSource` (`TEXT`), optional (default: `nil`).
    public var romDumpSource : String?
    
    /**
     * Initialize a new ``ROMs`` record.
     * 
     * - Parameters:
     *   - id: Primary key `romID` (`INTEGER`), optional (default: `nil`).
     *   - systemID: Column `systemID` (`INTEGER`), optional (default: `nil`).
     *   - regionID: Column `regionID` (`INTEGER`), optional (default: `nil`).
     *   - romHashCRC: Column `romHashCRC` (`TEXT`), optional (default: `nil`).
     *   - romHashMD5: Column `romHashMD5` (`TEXT`), optional (default: `nil`).
     *   - romHashSHA1: Column `romHashSHA1` (`TEXT`), optional (default: `nil`).
     *   - romSize: Column `romSize` (`INTEGER`), optional (default: `nil`).
     *   - romFileName: Column `romFileName` (`TEXT`), optional (default: `nil`).
     *   - romExtensionlessFileName: Column `romExtensionlessFileName` (`TEXT`), optional (default: `nil`).
     *   - romParent: Column `romParent` (`TEXT`), optional (default: `nil`).
     *   - romSerial: Column `romSerial` (`TEXT`), optional (default: `nil`).
     *   - romHeader: Column `romHeader` (`TEXT`), optional (default: `nil`).
     *   - romLanguage: Column `romLanguage` (`TEXT`), optional (default: `nil`).
     *   - tEMPromRegion: Column `TEMPromRegion` (`TEXT`), optional (default: `nil`).
     *   - romDumpSource: Column `romDumpSource` (`TEXT`), optional (default: `nil`).
     */
    @inlinable
    public init(
      id: Int? = nil,
      systemID: Int? = nil,
      regionID: Int? = nil,
      romHashCRC: String? = nil,
      romHashMD5: String? = nil,
      romHashSHA1: String? = nil,
      romSize: Int? = nil,
      romFileName: String? = nil,
      romExtensionlessFileName: String? = nil,
      romParent: String? = nil,
      romSerial: String? = nil,
      romHeader: String? = nil,
      romLanguage: String? = nil,
      tEMPromRegion: String? = nil,
      romDumpSource: String? = nil
    )
    {
      self.id = id
      self.systemID = systemID
      self.regionID = regionID
      self.romHashCRC = romHashCRC
      self.romHashMD5 = romHashMD5
      self.romHashSHA1 = romHashSHA1
      self.romSize = romSize
      self.romFileName = romFileName
      self.romExtensionlessFileName = romExtensionlessFileName
      self.romParent = romParent
      self.romSerial = romSerial
      self.romHeader = romHeader
      self.romLanguage = romLanguage
      self.tEMPromRegion = tEMPromRegion
      self.romDumpSource = romDumpSource
    }
  }
  
  /**
   * Record representing the `SYSTEMS` SQL table.
   * 
   * Record types represent rows within tables&views in a SQLite database.
   * They are returned by the functions or queries/filters generated by
   * Enlighter.
   * 
   * ### Examples
   * 
   * Perform record operations on ``SYSTEMS`` records:
   * ```swift
   * let records = try await db.sYSTEMS.filter(orderBy: \.systemName) {
   *   $0.systemName != nil
   * }
   * ```
   * 
   * Perform column selects on the `SYSTEMS` table:
   * ```swift
   * let values = try await db.select(from: \.sYSTEMS, \.systemName) {
   *   $0.in([ 2, 3 ])
   * }
   * ```
   * 
   * ### SQL
   * 
   * The SQL used to create the table associated with the record:
   * ```sql
   * CREATE TABLE "SYSTEMS" (
   * "systemID" INTEGER PRIMARY KEY AUTOINCREMENT,
   * "systemName" TEXT,
   * "systemShortName" TEXT,
   * "systemHeaderSizeBytes" INTEGER,
   * "systemHashless" INTEGER,
   * "systemHeader" INTEGER,
   * "systemSerial" TEXT,
   * "systemOEID" TEXT
   * )
   * ```
   */
  public struct SYSTEMS : Identifiable, SQLKeyedTableRecord, Codable, Sendable {
    
    /// Static SQL type information for the ``SYSTEMS`` record.
    public static let schema = Schema()
    
    /// Primary key `systemID` (`INTEGER`), optional (default: `nil`).
    public var id : Int?
    
    /// Column `systemName` (`TEXT`), optional (default: `nil`).
    public var systemName : String?
    
    /// Column `systemShortName` (`TEXT`), optional (default: `nil`).
    public var systemShortName : String?
    
    /// Column `systemHeaderSizeBytes` (`INTEGER`), optional (default: `nil`).
    public var systemHeaderSizeBytes : Int?
    
    /// Column `systemHashless` (`INTEGER`), optional (default: `nil`).
    public var systemHashless : Int?
    
    /// Column `systemHeader` (`INTEGER`), optional (default: `nil`).
    public var systemHeader : Int?
    
    /// Column `systemSerial` (`TEXT`), optional (default: `nil`).
    public var systemSerial : String?
    
    /// Column `systemOEID` (`TEXT`), optional (default: `nil`).
    public var systemOEID : String?
    
    /**
     * Initialize a new ``SYSTEMS`` record.
     * 
     * - Parameters:
     *   - id: Primary key `systemID` (`INTEGER`), optional (default: `nil`).
     *   - systemName: Column `systemName` (`TEXT`), optional (default: `nil`).
     *   - systemShortName: Column `systemShortName` (`TEXT`), optional (default: `nil`).
     *   - systemHeaderSizeBytes: Column `systemHeaderSizeBytes` (`INTEGER`), optional (default: `nil`).
     *   - systemHashless: Column `systemHashless` (`INTEGER`), optional (default: `nil`).
     *   - systemHeader: Column `systemHeader` (`INTEGER`), optional (default: `nil`).
     *   - systemSerial: Column `systemSerial` (`TEXT`), optional (default: `nil`).
     *   - systemOEID: Column `systemOEID` (`TEXT`), optional (default: `nil`).
     */
    @inlinable
    public init(
      id: Int? = nil,
      systemName: String? = nil,
      systemShortName: String? = nil,
      systemHeaderSizeBytes: Int? = nil,
      systemHashless: Int? = nil,
      systemHeader: Int? = nil,
      systemSerial: String? = nil,
      systemOEID: String? = nil
    )
    {
      self.id = id
      self.systemName = systemName
      self.systemShortName = systemShortName
      self.systemHeaderSizeBytes = systemHeaderSizeBytes
      self.systemHashless = systemHashless
      self.systemHeader = systemHeader
      self.systemSerial = systemSerial
      self.systemOEID = systemOEID
    }
  }
  
  /// Property based access to the ``RecordTypes-swift.struct``.
  public static let recordTypes = RecordTypes()
  
  #if swift(>=5.7)
  /// All RecordTypes defined in the database.
  public static let _allRecordTypes : [ any SQLRecord.Type ] = [ REGIONS.self, RELEASES.self, ROMs.self, SYSTEMS.self ]
  #endif // swift(>=5.7)
  
  /// User version of the database (`PRAGMA user_version`).
  public static let userVersion = 0
  
  /// Whether `INSERT â€¦ RETURNING` should be used (requires SQLite 3.35.0+).
  public static let useInsertReturning = sqlite3_libversion_number() >= 3035000
  
  public static func withOptCString<R>(
    _ s: String?,
    _ body: ( UnsafePointer<CChar>? ) throws -> R
  ) rethrows -> R
  {
    if let s = s { return try s.withCString(body) }
    else { return try body(nil) }
  }
  
  /// The `connectionHandler` is used to open SQLite database connections.
  public var connectionHandler : SQLConnectionHandler
  
  /**
   * Initialize ``OpenvgdbSchema``, read-only, with a `URL`.
   * 
   * Configures the database with a simple connection pool opening the
   * specified `URL` read-only.
   * 
   * Example:
   * ```swift
   * let db = OpenvgdbSchema(url: ...)
   * 
   * // Write operations will raise an error.
   * let readOnly = OpenvgdbSchema(
   *   url: Bundle.module.url(forResource: "samples", withExtension: "db")
   * )
   * ```
   * 
   * - Parameters:
   *   - url: A `URL` pointing to the database to be used.
   */
  @inlinable
  public init(url: URL)
  {
    self.connectionHandler = .simplePool(url: url, readOnly: true)
  }
  
  /**
   * Initialize ``OpenvgdbSchema``, read-only, with a `URL`.
   * 
   * Configures the database with a simple connection pool opening the
   * specified `URL` read-only.
   * 
   * Example:
   * ```swift
   * let db = OpenvgdbSchema(url: ...)
   * 
   * // Write operations will raise an error.
   * let readOnly = OpenvgdbSchema(
   *   url: Bundle.module.url(forResource: "samples", withExtension: "db")
   * )
   * ```
   * 
   * - Parameters:
   *   - url: A `URL` pointing to the database to be used.
   *   - readOnly: For protocol conformance, only allowed value: `true`.
   */
  @inlinable
  public init(url: URL, readOnly: Bool = true)
  {
    self.init(url: url)
  }
  
  /**
   * Initialize ``OpenvgdbSchema`` w/ a `SQLConnectionHandler`.
   * 
   * `SQLConnectionHandler`'s are used to open SQLite database connections when
   * queries are run using the `Lighter` APIs.
   * The `SQLConnectionHandler` is a protocol and custom handlers
   * can be provided.
   * 
   * Example:
   * ```swift
   * let db = OpenvgdbSchema(connectionHandler: .simplePool(
   *   url: Bundle.module.url(forResource: "samples", withExtension: "db"),
   *   readOnly: true,
   *   maxAge: 10,
   *   maximumPoolSizePerConfiguration: 4
   * ))
   * ```
   * 
   * - Parameters:
   *   - connectionHandler: The `SQLConnectionHandler` to use w/ the database.
   */
  @inlinable
  public init(connectionHandler: SQLConnectionHandler)
  {
    self.connectionHandler = connectionHandler
  }
}

public extension OpenvgdbSchema.REGIONS {
  
  /**
   * Static type information for the ``REGIONS`` record (`REGIONS` SQL table).
   * 
   * This structure captures the static SQL information associated with the
   * record.
   * It is used for static type lookups and more.
   */
  struct Schema : SQLKeyedTableSchema, SQLSwiftMatchableSchema {
    
    public typealias PropertyIndices = ( idx_id: Int32, idx_regionName: Int32 )
    public typealias RecordType = OpenvgdbSchema.REGIONS
    public typealias MatchClosureType = ( OpenvgdbSchema.REGIONS ) -> Bool
    
    /// The SQL table name associated with the ``REGIONS`` record.
    public static let externalName = "REGIONS"
    
    /// The number of columns the `REGIONS` table has.
    public static let columnCount : Int32 = 2
    
    /// Information on the records primary key (``REGIONS/id``).
    public static let primaryKeyColumn = MappedColumn<OpenvgdbSchema.REGIONS, Int?>(
      externalName: "regionID",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.REGIONS.id
    )
    
    /// SQL to `SELECT` all columns of the `REGIONS` table.
    public static let select = #"SELECT "regionID", "regionName" FROM "REGIONS""#
    
    /// SQL fragment representing all columns.
    public static let selectColumns = #""regionID", "regionName""#
    
    /// Index positions of the properties in ``selectColumns``.
    public static let selectColumnIndices : PropertyIndices = ( 0, 1 )
    
    /// SQL to `SELECT` all columns of the `REGIONS` table using a Swift filter.
    public static let matchSelect = #"SELECT "regionID", "regionName" FROM "REGIONS" WHERE rEGIONS_swift_match("regionID", "regionName") != 0"#
    
    /// *Note*: Readonly database, do not use.
    public static let update = ""
    
    /// *Note*: Readonly database, do not use.
    public static let updateParameterIndices : PropertyIndices = ( -1, -1 )
    
    /// *Note*: Readonly database, do not use.
    public static let insert = ""
    
    /// *Note*: Readonly database, do not use.
    public static let insertReturning = ""
    
    /// *Note*: Readonly database, do not use.
    public static let insertParameterIndices : PropertyIndices = ( -1, -1 )
    
    /// *Note*: Readonly database, do not use.
    public static let delete = ""
    
    /// *Note*: Readonly database, do not use.
    public static let deleteParameterIndices : PropertyIndices = ( -1, -1 )
    
    /**
     * Lookup property indices by column name in a statement handle.
     * 
     * Properties are ordered in the schema and have a specific index
     * assigned.
     * E.g. if the record has two properties, `id` and `name`,
     * and the query was `SELECT age, REGIONS_id FROM REGIONS`,
     * this would return `( idx_id: 1, idx_name: -1 )`.
     * Because the `REGIONS_id` is in the second position and `name`
     * isn't provided at all.
     * 
     * - Parameters:
     *   - statement: A raw SQLite3 prepared statement handle.
     * - Returns: The positions of the properties in the prepared statement.
     */
    @inlinable
    public static func lookupColumnIndices(`in` statement: OpaquePointer!)
      -> PropertyIndices
    {
      var indices : PropertyIndices = ( -1, -1 )
      for i in 0..<sqlite3_column_count(statement) {
        let col = sqlite3_column_name(statement, i)
        if strcmp(col!, "regionID") == 0 {
          indices.idx_id = i
        }
        else if strcmp(col!, "regionName") == 0 {
          indices.idx_regionName = i
        }
      }
      return indices
    }
    
    /**
     * Register the Swift matcher function for the ``REGIONS`` record.
     * 
     * SQLite Swift matcher functions are used to process `filter` queries
     * and low-level matching w/o the Lighter library.
     * 
     * - Parameters:
     *   - unsafeDatabaseHandle: SQLite3 database handle.
     *   - flags: SQLite3 function registration flags, default: `SQLITE_UTF8`
     *   - matcher: A pointer to the Swift closure used to filter the records.
     * - Returns: The result code of `sqlite3_create_function`, e.g. `SQLITE_OK`.
     */
    @inlinable
    @discardableResult
    public static func registerSwiftMatcher(
      `in` unsafeDatabaseHandle: OpaquePointer!,
      flags: Int32 = SQLITE_UTF8,
      matcher: UnsafeRawPointer
    ) -> Int32
    {
      func dispatch(
        _ context: OpaquePointer?,
        argc: Int32,
        argv: UnsafeMutablePointer<OpaquePointer?>!
      )
      {
        if let closureRawPtr = sqlite3_user_data(context) {
          let closurePtr = closureRawPtr.bindMemory(to: MatchClosureType.self, capacity: 1)
          let indices = OpenvgdbSchema.REGIONS.Schema.selectColumnIndices
          let record = OpenvgdbSchema.REGIONS(
            id: (indices.idx_id >= 0) && (indices.idx_id < argc) ? (sqlite3_value_type(argv[Int(indices.idx_id)]) != SQLITE_NULL ? Int(sqlite3_value_int64(argv[Int(indices.idx_id)])) : nil) : RecordType.schema.id.defaultValue,
            regionName: (indices.idx_regionName >= 0) && (indices.idx_regionName < argc) ? (sqlite3_value_text(argv[Int(indices.idx_regionName)]).flatMap(String.init(cString:))) : RecordType.schema.regionName.defaultValue
          )
          sqlite3_result_int(context, closurePtr.pointee(record) ? 1 : 0)
        }
        else {
          sqlite3_result_error(context, "Missing Swift matcher closure", -1)
        }
      }
      return sqlite3_create_function(
        unsafeDatabaseHandle,
        "rEGIONS_swift_match",
        OpenvgdbSchema.REGIONS.Schema.columnCount,
        flags,
        UnsafeMutableRawPointer(mutating: matcher),
        dispatch,
        nil,
        nil
      )
    }
    
    /**
     * Unregister the Swift matcher function for the ``REGIONS`` record.
     * 
     * SQLite Swift matcher functions are used to process `filter` queries
     * and low-level matching w/o the Lighter library.
     * 
     * - Parameters:
     *   - unsafeDatabaseHandle: SQLite3 database handle.
     *   - flags: SQLite3 function registration flags, default: `SQLITE_UTF8`
     * - Returns: The result code of `sqlite3_create_function`, e.g. `SQLITE_OK`.
     */
    @inlinable
    @discardableResult
    public static func unregisterSwiftMatcher(
      `in` unsafeDatabaseHandle: OpaquePointer!,
      flags: Int32 = SQLITE_UTF8
    ) -> Int32
    {
      sqlite3_create_function(
        unsafeDatabaseHandle,
        "rEGIONS_swift_match",
        OpenvgdbSchema.REGIONS.Schema.columnCount,
        flags,
        nil,
        nil,
        nil,
        nil
      )
    }
    
    /// Type information for property ``REGIONS/id`` (`regionID` column).
    public let id = MappedColumn<OpenvgdbSchema.REGIONS, Int?>(
      externalName: "regionID",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.REGIONS.id
    )
    
    /// Type information for property ``REGIONS/regionName`` (`regionName` column).
    public let regionName = MappedColumn<OpenvgdbSchema.REGIONS, String?>(
      externalName: "regionName",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.REGIONS.regionName
    )
    
    #if swift(>=5.7)
    public var _allColumns : [ any SQLColumn ] { [ id, regionName ] }
    #endif // swift(>=5.7)
    
    public init()
    {
    }
  }
  
  /**
   * Initialize a ``REGIONS`` record from a SQLite statement handle.
   * 
   * This initializer allows easy setup of a record structure from an
   * otherwise arbitrarily constructed SQLite prepared statement.
   * 
   * If no `indices` are specified, the `Schema/lookupColumnIndices`
   * function will be used to find the positions of the structure properties
   * based on their external name.
   * When looping, it is recommended to do the lookup once, and then
   * provide the `indices` to the initializer.
   * 
   * Required values that are missing in the statement are replaced with
   * their assigned default values, i.e. this can even be used to perform
   * partial selects w/ only a minor overhead (the extra space for a
   * record).
   * 
   * Example:
   * ```swift
   * var statement : OpaquePointer?
   * sqlite3_prepare_v2(dbHandle, "SELECT * FROM REGIONS", -1, &statement, nil)
   * while sqlite3_step(statement) == SQLITE_ROW {
   *   let record = REGIONS(statement)
   *   print("Fetched:", record)
   * }
   * sqlite3_finalize(statement)
   * ```
   * 
   * - Parameters:
   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.
   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).
   */
  @inlinable
  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)
  {
    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)
    let argc = sqlite3_column_count(statement)
    self.init(
      id: (indices.idx_id >= 0) && (indices.idx_id < argc) ? (sqlite3_column_type(statement, indices.idx_id) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_id)) : nil) : Self.schema.id.defaultValue,
      regionName: (indices.idx_regionName >= 0) && (indices.idx_regionName < argc) ? (sqlite3_column_text(statement, indices.idx_regionName).flatMap(String.init(cString:))) : Self.schema.regionName.defaultValue
    )
  }
  
  /**
   * Bind all ``REGIONS`` properties to a prepared statement and call a closure.
   * 
   * *Important*: The bindings are only valid within the closure being executed!
   * 
   * Example:
   * ```swift
   * var statement : OpaquePointer?
   * sqlite3_prepare_v2(
   *   dbHandle,
   *   #"UPDATE "REGIONS" SET "regionName" = ? WHERE "regionID" = ?"#,
   *   -1, &statement, nil
   * )
   * 
   * let record = REGIONS(id: 1, regionName: "Hello")
   * let ok = record.bind(to: statement, indices: ( 2, 1 )) {
   *   sqlite3_step(statement) == SQLITE_DONE
   * }
   * sqlite3_finalize(statement)
   * ```
   * 
   * - Parameters:
   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.
   *   - indices: The parameter positions for the bindings.
   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!
   * - Returns: Returns the result of the closure that is passed in.
   */
  @inlinable
  @discardableResult
  func bind<R>(
    to statement: OpaquePointer!,
    indices: Schema.PropertyIndices,
    then execute: () throws -> R
  ) rethrows -> R
  {
    if indices.idx_id >= 0 {
      if let id = id {
        sqlite3_bind_int64(statement, indices.idx_id, Int64(id))
      }
      else {
        sqlite3_bind_null(statement, indices.idx_id)
      }
    }
    return try OpenvgdbSchema.withOptCString(regionName) { ( s ) in
      if indices.idx_regionName >= 0 {
        sqlite3_bind_text(statement, indices.idx_regionName, s, -1, nil)
      }
      return try execute()
    }
  }
}

public extension OpenvgdbSchema.RELEASES {
  
  /**
   * Static type information for the ``RELEASES`` record (`RELEASES` SQL table).
   * 
   * This structure captures the static SQL information associated with the
   * record.
   * It is used for static type lookups and more.
   */
  struct Schema : SQLKeyedTableSchema, SQLSwiftMatchableSchema {
    
    public typealias PropertyIndices = ( idx_id: Int32, idx_romID: Int32, idx_releaseTitleName: Int32, idx_regionLocalizedID: Int32, idx_tEMPregionLocalizedName: Int32, idx_tEMPsystemShortName: Int32, idx_tEMPsystemName: Int32, idx_releaseCoverFront: Int32, idx_releaseCoverBack: Int32, idx_releaseCoverCart: Int32, idx_releaseCoverDisc: Int32, idx_releaseDescription: Int32, idx_releaseDeveloper: Int32, idx_releasePublisher: Int32, idx_releaseGenre: Int32, idx_releaseDate: Int32, idx_releaseReferenceURL: Int32, idx_releaseReferenceImageURL: Int32 )
    public typealias RecordType = OpenvgdbSchema.RELEASES
    public typealias MatchClosureType = ( OpenvgdbSchema.RELEASES ) -> Bool
    
    /// The SQL table name associated with the ``RELEASES`` record.
    public static let externalName = "RELEASES"
    
    /// The number of columns the `RELEASES` table has.
    public static let columnCount : Int32 = 18
    
    /// Information on the records primary key (``RELEASES/id``).
    public static let primaryKeyColumn = MappedColumn<OpenvgdbSchema.RELEASES, Int?>(
      externalName: "releaseID",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.id
    )
    
    /// SQL to `SELECT` all columns of the `RELEASES` table.
    public static let select = #"SELECT "releaseID", "romID", "releaseTitleName", "regionLocalizedID", "TEMPregionLocalizedName", "TEMPsystemShortName", "TEMPsystemName", "releaseCoverFront", "releaseCoverBack", "releaseCoverCart", "releaseCoverDisc", "releaseDescription", "releaseDeveloper", "releasePublisher", "releaseGenre", "releaseDate", "releaseReferenceURL", "releaseReferenceImageURL" FROM "RELEASES""#
    
    /// SQL fragment representing all columns.
    public static let selectColumns = #""releaseID", "romID", "releaseTitleName", "regionLocalizedID", "TEMPregionLocalizedName", "TEMPsystemShortName", "TEMPsystemName", "releaseCoverFront", "releaseCoverBack", "releaseCoverCart", "releaseCoverDisc", "releaseDescription", "releaseDeveloper", "releasePublisher", "releaseGenre", "releaseDate", "releaseReferenceURL", "releaseReferenceImageURL""#
    
    /// Index positions of the properties in ``selectColumns``.
    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 )
    
    /// SQL to `SELECT` all columns of the `RELEASES` table using a Swift filter.
    public static let matchSelect = #"SELECT "releaseID", "romID", "releaseTitleName", "regionLocalizedID", "TEMPregionLocalizedName", "TEMPsystemShortName", "TEMPsystemName", "releaseCoverFront", "releaseCoverBack", "releaseCoverCart", "releaseCoverDisc", "releaseDescription", "releaseDeveloper", "releasePublisher", "releaseGenre", "releaseDate", "releaseReferenceURL", "releaseReferenceImageURL" FROM "RELEASES" WHERE rELEASES_swift_match("releaseID", "romID", "releaseTitleName", "regionLocalizedID", "TEMPregionLocalizedName", "TEMPsystemShortName", "TEMPsystemName", "releaseCoverFront", "releaseCoverBack", "releaseCoverCart", "releaseCoverDisc", "releaseDescription", "releaseDeveloper", "releasePublisher", "releaseGenre", "releaseDate", "releaseReferenceURL", "releaseReferenceImageURL") != 0"#
    
    /// *Note*: Readonly database, do not use.
    public static let update = ""
    
    /// *Note*: Readonly database, do not use.
    public static let updateParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )
    
    /// *Note*: Readonly database, do not use.
    public static let insert = ""
    
    /// *Note*: Readonly database, do not use.
    public static let insertReturning = ""
    
    /// *Note*: Readonly database, do not use.
    public static let insertParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )
    
    /// *Note*: Readonly database, do not use.
    public static let delete = ""
    
    /// *Note*: Readonly database, do not use.
    public static let deleteParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )
    
    /**
     * Lookup property indices by column name in a statement handle.
     * 
     * Properties are ordered in the schema and have a specific index
     * assigned.
     * E.g. if the record has two properties, `id` and `name`,
     * and the query was `SELECT age, RELEASES_id FROM RELEASES`,
     * this would return `( idx_id: 1, idx_name: -1 )`.
     * Because the `RELEASES_id` is in the second position and `name`
     * isn't provided at all.
     * 
     * - Parameters:
     *   - statement: A raw SQLite3 prepared statement handle.
     * - Returns: The positions of the properties in the prepared statement.
     */
    @inlinable
    public static func lookupColumnIndices(`in` statement: OpaquePointer!)
      -> PropertyIndices
    {
      var indices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )
      for i in 0..<sqlite3_column_count(statement) {
        let col = sqlite3_column_name(statement, i)
        if strcmp(col!, "releaseID") == 0 {
          indices.idx_id = i
        }
        else if strcmp(col!, "romID") == 0 {
          indices.idx_romID = i
        }
        else if strcmp(col!, "releaseTitleName") == 0 {
          indices.idx_releaseTitleName = i
        }
        else if strcmp(col!, "regionLocalizedID") == 0 {
          indices.idx_regionLocalizedID = i
        }
        else if strcmp(col!, "TEMPregionLocalizedName") == 0 {
          indices.idx_tEMPregionLocalizedName = i
        }
        else if strcmp(col!, "TEMPsystemShortName") == 0 {
          indices.idx_tEMPsystemShortName = i
        }
        else if strcmp(col!, "TEMPsystemName") == 0 {
          indices.idx_tEMPsystemName = i
        }
        else if strcmp(col!, "releaseCoverFront") == 0 {
          indices.idx_releaseCoverFront = i
        }
        else if strcmp(col!, "releaseCoverBack") == 0 {
          indices.idx_releaseCoverBack = i
        }
        else if strcmp(col!, "releaseCoverCart") == 0 {
          indices.idx_releaseCoverCart = i
        }
        else if strcmp(col!, "releaseCoverDisc") == 0 {
          indices.idx_releaseCoverDisc = i
        }
        else if strcmp(col!, "releaseDescription") == 0 {
          indices.idx_releaseDescription = i
        }
        else if strcmp(col!, "releaseDeveloper") == 0 {
          indices.idx_releaseDeveloper = i
        }
        else if strcmp(col!, "releasePublisher") == 0 {
          indices.idx_releasePublisher = i
        }
        else if strcmp(col!, "releaseGenre") == 0 {
          indices.idx_releaseGenre = i
        }
        else if strcmp(col!, "releaseDate") == 0 {
          indices.idx_releaseDate = i
        }
        else if strcmp(col!, "releaseReferenceURL") == 0 {
          indices.idx_releaseReferenceURL = i
        }
        else if strcmp(col!, "releaseReferenceImageURL") == 0 {
          indices.idx_releaseReferenceImageURL = i
        }
      }
      return indices
    }
    
    /**
     * Register the Swift matcher function for the ``RELEASES`` record.
     * 
     * SQLite Swift matcher functions are used to process `filter` queries
     * and low-level matching w/o the Lighter library.
     * 
     * - Parameters:
     *   - unsafeDatabaseHandle: SQLite3 database handle.
     *   - flags: SQLite3 function registration flags, default: `SQLITE_UTF8`
     *   - matcher: A pointer to the Swift closure used to filter the records.
     * - Returns: The result code of `sqlite3_create_function`, e.g. `SQLITE_OK`.
     */
    @inlinable
    @discardableResult
    public static func registerSwiftMatcher(
      `in` unsafeDatabaseHandle: OpaquePointer!,
      flags: Int32 = SQLITE_UTF8,
      matcher: UnsafeRawPointer
    ) -> Int32
    {
      func dispatch(
        _ context: OpaquePointer?,
        argc: Int32,
        argv: UnsafeMutablePointer<OpaquePointer?>!
      )
      {
        if let closureRawPtr = sqlite3_user_data(context) {
          let closurePtr = closureRawPtr.bindMemory(to: MatchClosureType.self, capacity: 1)
          let indices = OpenvgdbSchema.RELEASES.Schema.selectColumnIndices
          let record = OpenvgdbSchema.RELEASES(
            id: (indices.idx_id >= 0) && (indices.idx_id < argc) ? (sqlite3_value_type(argv[Int(indices.idx_id)]) != SQLITE_NULL ? Int(sqlite3_value_int64(argv[Int(indices.idx_id)])) : nil) : RecordType.schema.id.defaultValue,
            romID: (indices.idx_romID >= 0) && (indices.idx_romID < argc) ? (sqlite3_value_type(argv[Int(indices.idx_romID)]) != SQLITE_NULL ? Int(sqlite3_value_int64(argv[Int(indices.idx_romID)])) : nil) : RecordType.schema.romID.defaultValue,
            releaseTitleName: (indices.idx_releaseTitleName >= 0) && (indices.idx_releaseTitleName < argc) ? (sqlite3_value_text(argv[Int(indices.idx_releaseTitleName)]).flatMap(String.init(cString:))) : RecordType.schema.releaseTitleName.defaultValue,
            regionLocalizedID: (indices.idx_regionLocalizedID >= 0) && (indices.idx_regionLocalizedID < argc) ? (sqlite3_value_type(argv[Int(indices.idx_regionLocalizedID)]) != SQLITE_NULL ? Int(sqlite3_value_int64(argv[Int(indices.idx_regionLocalizedID)])) : nil) : RecordType.schema.regionLocalizedID.defaultValue,
            tEMPregionLocalizedName: (indices.idx_tEMPregionLocalizedName >= 0) && (indices.idx_tEMPregionLocalizedName < argc) ? (sqlite3_value_text(argv[Int(indices.idx_tEMPregionLocalizedName)]).flatMap(String.init(cString:))) : RecordType.schema.tEMPregionLocalizedName.defaultValue,
            tEMPsystemShortName: (indices.idx_tEMPsystemShortName >= 0) && (indices.idx_tEMPsystemShortName < argc) ? (sqlite3_value_text(argv[Int(indices.idx_tEMPsystemShortName)]).flatMap(String.init(cString:))) : RecordType.schema.tEMPsystemShortName.defaultValue,
            tEMPsystemName: (indices.idx_tEMPsystemName >= 0) && (indices.idx_tEMPsystemName < argc) ? (sqlite3_value_text(argv[Int(indices.idx_tEMPsystemName)]).flatMap(String.init(cString:))) : RecordType.schema.tEMPsystemName.defaultValue,
            releaseCoverFront: (indices.idx_releaseCoverFront >= 0) && (indices.idx_releaseCoverFront < argc) ? (sqlite3_value_text(argv[Int(indices.idx_releaseCoverFront)]).flatMap(String.init(cString:))) : RecordType.schema.releaseCoverFront.defaultValue,
            releaseCoverBack: (indices.idx_releaseCoverBack >= 0) && (indices.idx_releaseCoverBack < argc) ? (sqlite3_value_text(argv[Int(indices.idx_releaseCoverBack)]).flatMap(String.init(cString:))) : RecordType.schema.releaseCoverBack.defaultValue,
            releaseCoverCart: (indices.idx_releaseCoverCart >= 0) && (indices.idx_releaseCoverCart < argc) ? (sqlite3_value_text(argv[Int(indices.idx_releaseCoverCart)]).flatMap(String.init(cString:))) : RecordType.schema.releaseCoverCart.defaultValue,
            releaseCoverDisc: (indices.idx_releaseCoverDisc >= 0) && (indices.idx_releaseCoverDisc < argc) ? (sqlite3_value_text(argv[Int(indices.idx_releaseCoverDisc)]).flatMap(String.init(cString:))) : RecordType.schema.releaseCoverDisc.defaultValue,
            releaseDescription: (indices.idx_releaseDescription >= 0) && (indices.idx_releaseDescription < argc) ? (sqlite3_value_text(argv[Int(indices.idx_releaseDescription)]).flatMap(String.init(cString:))) : RecordType.schema.releaseDescription.defaultValue,
            releaseDeveloper: (indices.idx_releaseDeveloper >= 0) && (indices.idx_releaseDeveloper < argc) ? (sqlite3_value_text(argv[Int(indices.idx_releaseDeveloper)]).flatMap(String.init(cString:))) : RecordType.schema.releaseDeveloper.defaultValue,
            releasePublisher: (indices.idx_releasePublisher >= 0) && (indices.idx_releasePublisher < argc) ? (sqlite3_value_text(argv[Int(indices.idx_releasePublisher)]).flatMap(String.init(cString:))) : RecordType.schema.releasePublisher.defaultValue,
            releaseGenre: (indices.idx_releaseGenre >= 0) && (indices.idx_releaseGenre < argc) ? (sqlite3_value_text(argv[Int(indices.idx_releaseGenre)]).flatMap(String.init(cString:))) : RecordType.schema.releaseGenre.defaultValue,
            releaseDate: (indices.idx_releaseDate >= 0) && (indices.idx_releaseDate < argc) ? (sqlite3_value_text(argv[Int(indices.idx_releaseDate)]).flatMap(String.init(cString:))) : RecordType.schema.releaseDate.defaultValue,
            releaseReferenceURL: (indices.idx_releaseReferenceURL >= 0) && (indices.idx_releaseReferenceURL < argc) ? (sqlite3_value_text(argv[Int(indices.idx_releaseReferenceURL)]).flatMap(String.init(cString:))) : RecordType.schema.releaseReferenceURL.defaultValue,
            releaseReferenceImageURL: (indices.idx_releaseReferenceImageURL >= 0) && (indices.idx_releaseReferenceImageURL < argc) ? (sqlite3_value_text(argv[Int(indices.idx_releaseReferenceImageURL)]).flatMap(String.init(cString:))) : RecordType.schema.releaseReferenceImageURL.defaultValue
          )
          sqlite3_result_int(context, closurePtr.pointee(record) ? 1 : 0)
        }
        else {
          sqlite3_result_error(context, "Missing Swift matcher closure", -1)
        }
      }
      return sqlite3_create_function(
        unsafeDatabaseHandle,
        "rELEASES_swift_match",
        OpenvgdbSchema.RELEASES.Schema.columnCount,
        flags,
        UnsafeMutableRawPointer(mutating: matcher),
        dispatch,
        nil,
        nil
      )
    }
    
    /**
     * Unregister the Swift matcher function for the ``RELEASES`` record.
     * 
     * SQLite Swift matcher functions are used to process `filter` queries
     * and low-level matching w/o the Lighter library.
     * 
     * - Parameters:
     *   - unsafeDatabaseHandle: SQLite3 database handle.
     *   - flags: SQLite3 function registration flags, default: `SQLITE_UTF8`
     * - Returns: The result code of `sqlite3_create_function`, e.g. `SQLITE_OK`.
     */
    @inlinable
    @discardableResult
    public static func unregisterSwiftMatcher(
      `in` unsafeDatabaseHandle: OpaquePointer!,
      flags: Int32 = SQLITE_UTF8
    ) -> Int32
    {
      sqlite3_create_function(
        unsafeDatabaseHandle,
        "rELEASES_swift_match",
        OpenvgdbSchema.RELEASES.Schema.columnCount,
        flags,
        nil,
        nil,
        nil,
        nil
      )
    }
    
    /// Type information for property ``RELEASES/id`` (`releaseID` column).
    public let id = MappedColumn<OpenvgdbSchema.RELEASES, Int?>(
      externalName: "releaseID",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.id
    )
    
    /// Type information for property ``RELEASES/romID`` (`romID` column).
    public let romID = MappedColumn<OpenvgdbSchema.RELEASES, Int?>(
      externalName: "romID",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.romID
    )
    
    /// Type information for property ``RELEASES/releaseTitleName`` (`releaseTitleName` column).
    public let releaseTitleName = MappedColumn<OpenvgdbSchema.RELEASES, String?>(
      externalName: "releaseTitleName",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.releaseTitleName
    )
    
    /// Type information for property ``RELEASES/regionLocalizedID`` (`regionLocalizedID` column).
    public let regionLocalizedID = MappedColumn<OpenvgdbSchema.RELEASES, Int?>(
      externalName: "regionLocalizedID",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.regionLocalizedID
    )
    
    /// Type information for property ``RELEASES/tEMPregionLocalizedName`` (`TEMPregionLocalizedName` column).
    public let tEMPregionLocalizedName = MappedColumn<OpenvgdbSchema.RELEASES, String?>(
      externalName: "TEMPregionLocalizedName",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.tEMPregionLocalizedName
    )
    
    /// Type information for property ``RELEASES/tEMPsystemShortName`` (`TEMPsystemShortName` column).
    public let tEMPsystemShortName = MappedColumn<OpenvgdbSchema.RELEASES, String?>(
      externalName: "TEMPsystemShortName",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.tEMPsystemShortName
    )
    
    /// Type information for property ``RELEASES/tEMPsystemName`` (`TEMPsystemName` column).
    public let tEMPsystemName = MappedColumn<OpenvgdbSchema.RELEASES, String?>(
      externalName: "TEMPsystemName",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.tEMPsystemName
    )
    
    /// Type information for property ``RELEASES/releaseCoverFront`` (`releaseCoverFront` column).
    public let releaseCoverFront = MappedColumn<OpenvgdbSchema.RELEASES, String?>(
      externalName: "releaseCoverFront",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.releaseCoverFront
    )
    
    /// Type information for property ``RELEASES/releaseCoverBack`` (`releaseCoverBack` column).
    public let releaseCoverBack = MappedColumn<OpenvgdbSchema.RELEASES, String?>(
      externalName: "releaseCoverBack",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.releaseCoverBack
    )
    
    /// Type information for property ``RELEASES/releaseCoverCart`` (`releaseCoverCart` column).
    public let releaseCoverCart = MappedColumn<OpenvgdbSchema.RELEASES, String?>(
      externalName: "releaseCoverCart",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.releaseCoverCart
    )
    
    /// Type information for property ``RELEASES/releaseCoverDisc`` (`releaseCoverDisc` column).
    public let releaseCoverDisc = MappedColumn<OpenvgdbSchema.RELEASES, String?>(
      externalName: "releaseCoverDisc",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.releaseCoverDisc
    )
    
    /// Type information for property ``RELEASES/releaseDescription`` (`releaseDescription` column).
    public let releaseDescription = MappedColumn<OpenvgdbSchema.RELEASES, String?>(
      externalName: "releaseDescription",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.releaseDescription
    )
    
    /// Type information for property ``RELEASES/releaseDeveloper`` (`releaseDeveloper` column).
    public let releaseDeveloper = MappedColumn<OpenvgdbSchema.RELEASES, String?>(
      externalName: "releaseDeveloper",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.releaseDeveloper
    )
    
    /// Type information for property ``RELEASES/releasePublisher`` (`releasePublisher` column).
    public let releasePublisher = MappedColumn<OpenvgdbSchema.RELEASES, String?>(
      externalName: "releasePublisher",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.releasePublisher
    )
    
    /// Type information for property ``RELEASES/releaseGenre`` (`releaseGenre` column).
    public let releaseGenre = MappedColumn<OpenvgdbSchema.RELEASES, String?>(
      externalName: "releaseGenre",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.releaseGenre
    )
    
    /// Type information for property ``RELEASES/releaseDate`` (`releaseDate` column).
    public let releaseDate = MappedColumn<OpenvgdbSchema.RELEASES, String?>(
      externalName: "releaseDate",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.releaseDate
    )
    
    /// Type information for property ``RELEASES/releaseReferenceURL`` (`releaseReferenceURL` column).
    public let releaseReferenceURL = MappedColumn<OpenvgdbSchema.RELEASES, String?>(
      externalName: "releaseReferenceURL",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.releaseReferenceURL
    )
    
    /// Type information for property ``RELEASES/releaseReferenceImageURL`` (`releaseReferenceImageURL` column).
    public let releaseReferenceImageURL = MappedColumn<OpenvgdbSchema.RELEASES, String?>(
      externalName: "releaseReferenceImageURL",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.RELEASES.releaseReferenceImageURL
    )
    
    #if swift(>=5.7)
    public var _allColumns : [ any SQLColumn ] { [ id, romID, releaseTitleName, regionLocalizedID, tEMPregionLocalizedName, tEMPsystemShortName, tEMPsystemName, releaseCoverFront, releaseCoverBack, releaseCoverCart, releaseCoverDisc, releaseDescription, releaseDeveloper, releasePublisher, releaseGenre, releaseDate, releaseReferenceURL, releaseReferenceImageURL ] }
    #endif // swift(>=5.7)
    
    public init()
    {
    }
  }
  
  /**
   * Initialize a ``RELEASES`` record from a SQLite statement handle.
   * 
   * This initializer allows easy setup of a record structure from an
   * otherwise arbitrarily constructed SQLite prepared statement.
   * 
   * If no `indices` are specified, the `Schema/lookupColumnIndices`
   * function will be used to find the positions of the structure properties
   * based on their external name.
   * When looping, it is recommended to do the lookup once, and then
   * provide the `indices` to the initializer.
   * 
   * Required values that are missing in the statement are replaced with
   * their assigned default values, i.e. this can even be used to perform
   * partial selects w/ only a minor overhead (the extra space for a
   * record).
   * 
   * Example:
   * ```swift
   * var statement : OpaquePointer?
   * sqlite3_prepare_v2(dbHandle, "SELECT * FROM RELEASES", -1, &statement, nil)
   * while sqlite3_step(statement) == SQLITE_ROW {
   *   let record = RELEASES(statement)
   *   print("Fetched:", record)
   * }
   * sqlite3_finalize(statement)
   * ```
   * 
   * - Parameters:
   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.
   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).
   */
  @inlinable
  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)
  {
    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)
    let argc = sqlite3_column_count(statement)
    self.init(
      id: (indices.idx_id >= 0) && (indices.idx_id < argc) ? (sqlite3_column_type(statement, indices.idx_id) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_id)) : nil) : Self.schema.id.defaultValue,
      romID: (indices.idx_romID >= 0) && (indices.idx_romID < argc) ? (sqlite3_column_type(statement, indices.idx_romID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_romID)) : nil) : Self.schema.romID.defaultValue,
      releaseTitleName: (indices.idx_releaseTitleName >= 0) && (indices.idx_releaseTitleName < argc) ? (sqlite3_column_text(statement, indices.idx_releaseTitleName).flatMap(String.init(cString:))) : Self.schema.releaseTitleName.defaultValue,
      regionLocalizedID: (indices.idx_regionLocalizedID >= 0) && (indices.idx_regionLocalizedID < argc) ? (sqlite3_column_type(statement, indices.idx_regionLocalizedID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_regionLocalizedID)) : nil) : Self.schema.regionLocalizedID.defaultValue,
      tEMPregionLocalizedName: (indices.idx_tEMPregionLocalizedName >= 0) && (indices.idx_tEMPregionLocalizedName < argc) ? (sqlite3_column_text(statement, indices.idx_tEMPregionLocalizedName).flatMap(String.init(cString:))) : Self.schema.tEMPregionLocalizedName.defaultValue,
      tEMPsystemShortName: (indices.idx_tEMPsystemShortName >= 0) && (indices.idx_tEMPsystemShortName < argc) ? (sqlite3_column_text(statement, indices.idx_tEMPsystemShortName).flatMap(String.init(cString:))) : Self.schema.tEMPsystemShortName.defaultValue,
      tEMPsystemName: (indices.idx_tEMPsystemName >= 0) && (indices.idx_tEMPsystemName < argc) ? (sqlite3_column_text(statement, indices.idx_tEMPsystemName).flatMap(String.init(cString:))) : Self.schema.tEMPsystemName.defaultValue,
      releaseCoverFront: (indices.idx_releaseCoverFront >= 0) && (indices.idx_releaseCoverFront < argc) ? (sqlite3_column_text(statement, indices.idx_releaseCoverFront).flatMap(String.init(cString:))) : Self.schema.releaseCoverFront.defaultValue,
      releaseCoverBack: (indices.idx_releaseCoverBack >= 0) && (indices.idx_releaseCoverBack < argc) ? (sqlite3_column_text(statement, indices.idx_releaseCoverBack).flatMap(String.init(cString:))) : Self.schema.releaseCoverBack.defaultValue,
      releaseCoverCart: (indices.idx_releaseCoverCart >= 0) && (indices.idx_releaseCoverCart < argc) ? (sqlite3_column_text(statement, indices.idx_releaseCoverCart).flatMap(String.init(cString:))) : Self.schema.releaseCoverCart.defaultValue,
      releaseCoverDisc: (indices.idx_releaseCoverDisc >= 0) && (indices.idx_releaseCoverDisc < argc) ? (sqlite3_column_text(statement, indices.idx_releaseCoverDisc).flatMap(String.init(cString:))) : Self.schema.releaseCoverDisc.defaultValue,
      releaseDescription: (indices.idx_releaseDescription >= 0) && (indices.idx_releaseDescription < argc) ? (sqlite3_column_text(statement, indices.idx_releaseDescription).flatMap(String.init(cString:))) : Self.schema.releaseDescription.defaultValue,
      releaseDeveloper: (indices.idx_releaseDeveloper >= 0) && (indices.idx_releaseDeveloper < argc) ? (sqlite3_column_text(statement, indices.idx_releaseDeveloper).flatMap(String.init(cString:))) : Self.schema.releaseDeveloper.defaultValue,
      releasePublisher: (indices.idx_releasePublisher >= 0) && (indices.idx_releasePublisher < argc) ? (sqlite3_column_text(statement, indices.idx_releasePublisher).flatMap(String.init(cString:))) : Self.schema.releasePublisher.defaultValue,
      releaseGenre: (indices.idx_releaseGenre >= 0) && (indices.idx_releaseGenre < argc) ? (sqlite3_column_text(statement, indices.idx_releaseGenre).flatMap(String.init(cString:))) : Self.schema.releaseGenre.defaultValue,
      releaseDate: (indices.idx_releaseDate >= 0) && (indices.idx_releaseDate < argc) ? (sqlite3_column_text(statement, indices.idx_releaseDate).flatMap(String.init(cString:))) : Self.schema.releaseDate.defaultValue,
      releaseReferenceURL: (indices.idx_releaseReferenceURL >= 0) && (indices.idx_releaseReferenceURL < argc) ? (sqlite3_column_text(statement, indices.idx_releaseReferenceURL).flatMap(String.init(cString:))) : Self.schema.releaseReferenceURL.defaultValue,
      releaseReferenceImageURL: (indices.idx_releaseReferenceImageURL >= 0) && (indices.idx_releaseReferenceImageURL < argc) ? (sqlite3_column_text(statement, indices.idx_releaseReferenceImageURL).flatMap(String.init(cString:))) : Self.schema.releaseReferenceImageURL.defaultValue
    )
  }
  
  /**
   * Bind all ``RELEASES`` properties to a prepared statement and call a closure.
   * 
   * *Important*: The bindings are only valid within the closure being executed!
   * 
   * Example:
   * ```swift
   * var statement : OpaquePointer?
   * sqlite3_prepare_v2(
   *   dbHandle,
   *   #"UPDATE "RELEASES" SET "romID" = ?, "releaseTitleName" = ?, "regionLocalizedID" = ?, "TEMPregionLocalizedName" = ?, "TEMPsystemShortName" = ?, "TEMPsystemName" = ?, "releaseCoverFront" = ?, "releaseCoverBack" = ?, "releaseCoverCart" = ?, "releaseCoverDisc" = ?, "releaseDescription" = ?, "releaseDeveloper" = ?, "releasePublisher" = ?, "releaseGenre" = ?, "releaseDate" = ?, "releaseReferenceURL" = ?, "releaseReferenceImageURL" = ? WHERE "releaseID" = ?"#,
   *   -1, &statement, nil
   * )
   * 
   * let record = RELEASES(id: 1, romID: 2, releaseTitleName: "Hello", regionLocalizedID: 3)
   * let ok = record.bind(to: statement, indices: ( 18, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 )) {
   *   sqlite3_step(statement) == SQLITE_DONE
   * }
   * sqlite3_finalize(statement)
   * ```
   * 
   * - Parameters:
   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.
   *   - indices: The parameter positions for the bindings.
   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!
   * - Returns: Returns the result of the closure that is passed in.
   */
  @inlinable
  @discardableResult
  func bind<R>(
    to statement: OpaquePointer!,
    indices: Schema.PropertyIndices,
    then execute: () throws -> R
  ) rethrows -> R
  {
    if indices.idx_id >= 0 {
      if let id = id {
        sqlite3_bind_int64(statement, indices.idx_id, Int64(id))
      }
      else {
        sqlite3_bind_null(statement, indices.idx_id)
      }
    }
    if indices.idx_romID >= 0 {
      if let romID = romID {
        sqlite3_bind_int64(statement, indices.idx_romID, Int64(romID))
      }
      else {
        sqlite3_bind_null(statement, indices.idx_romID)
      }
    }
    return try OpenvgdbSchema.withOptCString(releaseTitleName) { ( s ) in
      if indices.idx_releaseTitleName >= 0 {
        sqlite3_bind_text(statement, indices.idx_releaseTitleName, s, -1, nil)
      }
      if indices.idx_regionLocalizedID >= 0 {
        if let regionLocalizedID = regionLocalizedID {
          sqlite3_bind_int64(
            statement,
            indices.idx_regionLocalizedID,
            Int64(regionLocalizedID)
          )
        }
        else {
          sqlite3_bind_null(statement, indices.idx_regionLocalizedID)
        }
      }
      return try OpenvgdbSchema.withOptCString(tEMPregionLocalizedName) { ( s ) in
        if indices.idx_tEMPregionLocalizedName >= 0 {
          sqlite3_bind_text(statement, indices.idx_tEMPregionLocalizedName, s, -1, nil)
        }
        return try OpenvgdbSchema.withOptCString(tEMPsystemShortName) { ( s ) in
          if indices.idx_tEMPsystemShortName >= 0 {
            sqlite3_bind_text(statement, indices.idx_tEMPsystemShortName, s, -1, nil)
          }
          return try OpenvgdbSchema.withOptCString(tEMPsystemName) { ( s ) in
            if indices.idx_tEMPsystemName >= 0 {
              sqlite3_bind_text(statement, indices.idx_tEMPsystemName, s, -1, nil)
            }
            return try OpenvgdbSchema.withOptCString(releaseCoverFront) { ( s ) in
              if indices.idx_releaseCoverFront >= 0 {
                sqlite3_bind_text(statement, indices.idx_releaseCoverFront, s, -1, nil)
              }
              return try OpenvgdbSchema.withOptCString(releaseCoverBack) { ( s ) in
                if indices.idx_releaseCoverBack >= 0 {
                  sqlite3_bind_text(statement, indices.idx_releaseCoverBack, s, -1, nil)
                }
                return try OpenvgdbSchema.withOptCString(releaseCoverCart) { ( s ) in
                  if indices.idx_releaseCoverCart >= 0 {
                    sqlite3_bind_text(statement, indices.idx_releaseCoverCart, s, -1, nil)
                  }
                  return try OpenvgdbSchema.withOptCString(releaseCoverDisc) { ( s ) in
                    if indices.idx_releaseCoverDisc >= 0 {
                      sqlite3_bind_text(statement, indices.idx_releaseCoverDisc, s, -1, nil)
                    }
                    return try OpenvgdbSchema.withOptCString(releaseDescription) { ( s ) in
                      if indices.idx_releaseDescription >= 0 {
                        sqlite3_bind_text(statement, indices.idx_releaseDescription, s, -1, nil)
                      }
                      return try OpenvgdbSchema.withOptCString(releaseDeveloper) { ( s ) in
                        if indices.idx_releaseDeveloper >= 0 {
                          sqlite3_bind_text(statement, indices.idx_releaseDeveloper, s, -1, nil)
                        }
                        return try OpenvgdbSchema.withOptCString(releasePublisher) { ( s ) in
                          if indices.idx_releasePublisher >= 0 {
                            sqlite3_bind_text(statement, indices.idx_releasePublisher, s, -1, nil)
                          }
                          return try OpenvgdbSchema.withOptCString(releaseGenre) { ( s ) in
                            if indices.idx_releaseGenre >= 0 {
                              sqlite3_bind_text(statement, indices.idx_releaseGenre, s, -1, nil)
                            }
                            return try OpenvgdbSchema.withOptCString(releaseDate) { ( s ) in
                              if indices.idx_releaseDate >= 0 {
                                sqlite3_bind_text(statement, indices.idx_releaseDate, s, -1, nil)
                              }
                              return try OpenvgdbSchema.withOptCString(releaseReferenceURL) { ( s ) in
                                if indices.idx_releaseReferenceURL >= 0 {
                                  sqlite3_bind_text(statement, indices.idx_releaseReferenceURL, s, -1, nil)
                                }
                                return try OpenvgdbSchema.withOptCString(releaseReferenceImageURL) { ( s ) in
                                  if indices.idx_releaseReferenceImageURL >= 0 {
                                    sqlite3_bind_text(statement, indices.idx_releaseReferenceImageURL, s, -1, nil)
                                  }
                                  return try execute()
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

public extension OpenvgdbSchema.ROMs {
  
  /**
   * Static type information for the ``ROMs`` record (`ROMs` SQL table).
   * 
   * This structure captures the static SQL information associated with the
   * record.
   * It is used for static type lookups and more.
   */
  struct Schema : SQLKeyedTableSchema, SQLSwiftMatchableSchema {
    
    public typealias PropertyIndices = ( idx_id: Int32, idx_systemID: Int32, idx_regionID: Int32, idx_romHashCRC: Int32, idx_romHashMD5: Int32, idx_romHashSHA1: Int32, idx_romSize: Int32, idx_romFileName: Int32, idx_romExtensionlessFileName: Int32, idx_romParent: Int32, idx_romSerial: Int32, idx_romHeader: Int32, idx_romLanguage: Int32, idx_tEMPromRegion: Int32, idx_romDumpSource: Int32 )
    public typealias RecordType = OpenvgdbSchema.ROMs
    public typealias MatchClosureType = ( OpenvgdbSchema.ROMs ) -> Bool
    
    /// The SQL table name associated with the ``ROMs`` record.
    public static let externalName = "ROMs"
    
    /// The number of columns the `ROMs` table has.
    public static let columnCount : Int32 = 15
    
    /// Information on the records primary key (``ROMs/id``).
    public static let primaryKeyColumn = MappedColumn<OpenvgdbSchema.ROMs, Int?>(
      externalName: "romID",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.ROMs.id
    )
    
    /// SQL to `SELECT` all columns of the `ROMs` table.
    public static let select = #"SELECT "romID", "systemID", "regionID", "romHashCRC", "romHashMD5", "romHashSHA1", "romSize", "romFileName", "romExtensionlessFileName", "romParent", "romSerial", "romHeader", "romLanguage", "TEMPromRegion", "romDumpSource" FROM "ROMs""#
    
    /// SQL fragment representing all columns.
    public static let selectColumns = #""romID", "systemID", "regionID", "romHashCRC", "romHashMD5", "romHashSHA1", "romSize", "romFileName", "romExtensionlessFileName", "romParent", "romSerial", "romHeader", "romLanguage", "TEMPromRegion", "romDumpSource""#
    
    /// Index positions of the properties in ``selectColumns``.
    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 )
    
    /// SQL to `SELECT` all columns of the `ROMs` table using a Swift filter.
    public static let matchSelect = #"SELECT "romID", "systemID", "regionID", "romHashCRC", "romHashMD5", "romHashSHA1", "romSize", "romFileName", "romExtensionlessFileName", "romParent", "romSerial", "romHeader", "romLanguage", "TEMPromRegion", "romDumpSource" FROM "ROMs" WHERE rOMs_swift_match("romID", "systemID", "regionID", "romHashCRC", "romHashMD5", "romHashSHA1", "romSize", "romFileName", "romExtensionlessFileName", "romParent", "romSerial", "romHeader", "romLanguage", "TEMPromRegion", "romDumpSource") != 0"#
    
    /// *Note*: Readonly database, do not use.
    public static let update = ""
    
    /// *Note*: Readonly database, do not use.
    public static let updateParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )
    
    /// *Note*: Readonly database, do not use.
    public static let insert = ""
    
    /// *Note*: Readonly database, do not use.
    public static let insertReturning = ""
    
    /// *Note*: Readonly database, do not use.
    public static let insertParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )
    
    /// *Note*: Readonly database, do not use.
    public static let delete = ""
    
    /// *Note*: Readonly database, do not use.
    public static let deleteParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )
    
    /**
     * Lookup property indices by column name in a statement handle.
     * 
     * Properties are ordered in the schema and have a specific index
     * assigned.
     * E.g. if the record has two properties, `id` and `name`,
     * and the query was `SELECT age, ROMs_id FROM ROMs`,
     * this would return `( idx_id: 1, idx_name: -1 )`.
     * Because the `ROMs_id` is in the second position and `name`
     * isn't provided at all.
     * 
     * - Parameters:
     *   - statement: A raw SQLite3 prepared statement handle.
     * - Returns: The positions of the properties in the prepared statement.
     */
    @inlinable
    public static func lookupColumnIndices(`in` statement: OpaquePointer!)
      -> PropertyIndices
    {
      var indices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 )
      for i in 0..<sqlite3_column_count(statement) {
        let col = sqlite3_column_name(statement, i)
        if strcmp(col!, "romID") == 0 {
          indices.idx_id = i
        }
        else if strcmp(col!, "systemID") == 0 {
          indices.idx_systemID = i
        }
        else if strcmp(col!, "regionID") == 0 {
          indices.idx_regionID = i
        }
        else if strcmp(col!, "romHashCRC") == 0 {
          indices.idx_romHashCRC = i
        }
        else if strcmp(col!, "romHashMD5") == 0 {
          indices.idx_romHashMD5 = i
        }
        else if strcmp(col!, "romHashSHA1") == 0 {
          indices.idx_romHashSHA1 = i
        }
        else if strcmp(col!, "romSize") == 0 {
          indices.idx_romSize = i
        }
        else if strcmp(col!, "romFileName") == 0 {
          indices.idx_romFileName = i
        }
        else if strcmp(col!, "romExtensionlessFileName") == 0 {
          indices.idx_romExtensionlessFileName = i
        }
        else if strcmp(col!, "romParent") == 0 {
          indices.idx_romParent = i
        }
        else if strcmp(col!, "romSerial") == 0 {
          indices.idx_romSerial = i
        }
        else if strcmp(col!, "romHeader") == 0 {
          indices.idx_romHeader = i
        }
        else if strcmp(col!, "romLanguage") == 0 {
          indices.idx_romLanguage = i
        }
        else if strcmp(col!, "TEMPromRegion") == 0 {
          indices.idx_tEMPromRegion = i
        }
        else if strcmp(col!, "romDumpSource") == 0 {
          indices.idx_romDumpSource = i
        }
      }
      return indices
    }
    
    /**
     * Register the Swift matcher function for the ``ROMs`` record.
     * 
     * SQLite Swift matcher functions are used to process `filter` queries
     * and low-level matching w/o the Lighter library.
     * 
     * - Parameters:
     *   - unsafeDatabaseHandle: SQLite3 database handle.
     *   - flags: SQLite3 function registration flags, default: `SQLITE_UTF8`
     *   - matcher: A pointer to the Swift closure used to filter the records.
     * - Returns: The result code of `sqlite3_create_function`, e.g. `SQLITE_OK`.
     */
    @inlinable
    @discardableResult
    public static func registerSwiftMatcher(
      `in` unsafeDatabaseHandle: OpaquePointer!,
      flags: Int32 = SQLITE_UTF8,
      matcher: UnsafeRawPointer
    ) -> Int32
    {
      func dispatch(
        _ context: OpaquePointer?,
        argc: Int32,
        argv: UnsafeMutablePointer<OpaquePointer?>!
      )
      {
        if let closureRawPtr = sqlite3_user_data(context) {
          let closurePtr = closureRawPtr.bindMemory(to: MatchClosureType.self, capacity: 1)
          let indices = OpenvgdbSchema.ROMs.Schema.selectColumnIndices
          let record = OpenvgdbSchema.ROMs(
            id: (indices.idx_id >= 0) && (indices.idx_id < argc) ? (sqlite3_value_type(argv[Int(indices.idx_id)]) != SQLITE_NULL ? Int(sqlite3_value_int64(argv[Int(indices.idx_id)])) : nil) : RecordType.schema.id.defaultValue,
            systemID: (indices.idx_systemID >= 0) && (indices.idx_systemID < argc) ? (sqlite3_value_type(argv[Int(indices.idx_systemID)]) != SQLITE_NULL ? Int(sqlite3_value_int64(argv[Int(indices.idx_systemID)])) : nil) : RecordType.schema.systemID.defaultValue,
            regionID: (indices.idx_regionID >= 0) && (indices.idx_regionID < argc) ? (sqlite3_value_type(argv[Int(indices.idx_regionID)]) != SQLITE_NULL ? Int(sqlite3_value_int64(argv[Int(indices.idx_regionID)])) : nil) : RecordType.schema.regionID.defaultValue,
            romHashCRC: (indices.idx_romHashCRC >= 0) && (indices.idx_romHashCRC < argc) ? (sqlite3_value_text(argv[Int(indices.idx_romHashCRC)]).flatMap(String.init(cString:))) : RecordType.schema.romHashCRC.defaultValue,
            romHashMD5: (indices.idx_romHashMD5 >= 0) && (indices.idx_romHashMD5 < argc) ? (sqlite3_value_text(argv[Int(indices.idx_romHashMD5)]).flatMap(String.init(cString:))) : RecordType.schema.romHashMD5.defaultValue,
            romHashSHA1: (indices.idx_romHashSHA1 >= 0) && (indices.idx_romHashSHA1 < argc) ? (sqlite3_value_text(argv[Int(indices.idx_romHashSHA1)]).flatMap(String.init(cString:))) : RecordType.schema.romHashSHA1.defaultValue,
            romSize: (indices.idx_romSize >= 0) && (indices.idx_romSize < argc) ? (sqlite3_value_type(argv[Int(indices.idx_romSize)]) != SQLITE_NULL ? Int(sqlite3_value_int64(argv[Int(indices.idx_romSize)])) : nil) : RecordType.schema.romSize.defaultValue,
            romFileName: (indices.idx_romFileName >= 0) && (indices.idx_romFileName < argc) ? (sqlite3_value_text(argv[Int(indices.idx_romFileName)]).flatMap(String.init(cString:))) : RecordType.schema.romFileName.defaultValue,
            romExtensionlessFileName: (indices.idx_romExtensionlessFileName >= 0) && (indices.idx_romExtensionlessFileName < argc) ? (sqlite3_value_text(argv[Int(indices.idx_romExtensionlessFileName)]).flatMap(String.init(cString:))) : RecordType.schema.romExtensionlessFileName.defaultValue,
            romParent: (indices.idx_romParent >= 0) && (indices.idx_romParent < argc) ? (sqlite3_value_text(argv[Int(indices.idx_romParent)]).flatMap(String.init(cString:))) : RecordType.schema.romParent.defaultValue,
            romSerial: (indices.idx_romSerial >= 0) && (indices.idx_romSerial < argc) ? (sqlite3_value_text(argv[Int(indices.idx_romSerial)]).flatMap(String.init(cString:))) : RecordType.schema.romSerial.defaultValue,
            romHeader: (indices.idx_romHeader >= 0) && (indices.idx_romHeader < argc) ? (sqlite3_value_text(argv[Int(indices.idx_romHeader)]).flatMap(String.init(cString:))) : RecordType.schema.romHeader.defaultValue,
            romLanguage: (indices.idx_romLanguage >= 0) && (indices.idx_romLanguage < argc) ? (sqlite3_value_text(argv[Int(indices.idx_romLanguage)]).flatMap(String.init(cString:))) : RecordType.schema.romLanguage.defaultValue,
            tEMPromRegion: (indices.idx_tEMPromRegion >= 0) && (indices.idx_tEMPromRegion < argc) ? (sqlite3_value_text(argv[Int(indices.idx_tEMPromRegion)]).flatMap(String.init(cString:))) : RecordType.schema.tEMPromRegion.defaultValue,
            romDumpSource: (indices.idx_romDumpSource >= 0) && (indices.idx_romDumpSource < argc) ? (sqlite3_value_text(argv[Int(indices.idx_romDumpSource)]).flatMap(String.init(cString:))) : RecordType.schema.romDumpSource.defaultValue
          )
          sqlite3_result_int(context, closurePtr.pointee(record) ? 1 : 0)
        }
        else {
          sqlite3_result_error(context, "Missing Swift matcher closure", -1)
        }
      }
      return sqlite3_create_function(
        unsafeDatabaseHandle,
        "rOMs_swift_match",
        OpenvgdbSchema.ROMs.Schema.columnCount,
        flags,
        UnsafeMutableRawPointer(mutating: matcher),
        dispatch,
        nil,
        nil
      )
    }
    
    /**
     * Unregister the Swift matcher function for the ``ROMs`` record.
     * 
     * SQLite Swift matcher functions are used to process `filter` queries
     * and low-level matching w/o the Lighter library.
     * 
     * - Parameters:
     *   - unsafeDatabaseHandle: SQLite3 database handle.
     *   - flags: SQLite3 function registration flags, default: `SQLITE_UTF8`
     * - Returns: The result code of `sqlite3_create_function`, e.g. `SQLITE_OK`.
     */
    @inlinable
    @discardableResult
    public static func unregisterSwiftMatcher(
      `in` unsafeDatabaseHandle: OpaquePointer!,
      flags: Int32 = SQLITE_UTF8
    ) -> Int32
    {
      sqlite3_create_function(
        unsafeDatabaseHandle,
        "rOMs_swift_match",
        OpenvgdbSchema.ROMs.Schema.columnCount,
        flags,
        nil,
        nil,
        nil,
        nil
      )
    }
    
    /// Type information for property ``ROMs/id`` (`romID` column).
    public let id = MappedColumn<OpenvgdbSchema.ROMs, Int?>(
      externalName: "romID",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.ROMs.id
    )
    
    /// Type information for property ``ROMs/systemID`` (`systemID` column).
    public let systemID = MappedColumn<OpenvgdbSchema.ROMs, Int?>(
      externalName: "systemID",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.ROMs.systemID
    )
    
    /// Type information for property ``ROMs/regionID`` (`regionID` column).
    public let regionID = MappedColumn<OpenvgdbSchema.ROMs, Int?>(
      externalName: "regionID",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.ROMs.regionID
    )
    
    /// Type information for property ``ROMs/romHashCRC`` (`romHashCRC` column).
    public let romHashCRC = MappedColumn<OpenvgdbSchema.ROMs, String?>(
      externalName: "romHashCRC",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.ROMs.romHashCRC
    )
    
    /// Type information for property ``ROMs/romHashMD5`` (`romHashMD5` column).
    public let romHashMD5 = MappedColumn<OpenvgdbSchema.ROMs, String?>(
      externalName: "romHashMD5",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.ROMs.romHashMD5
    )
    
    /// Type information for property ``ROMs/romHashSHA1`` (`romHashSHA1` column).
    public let romHashSHA1 = MappedColumn<OpenvgdbSchema.ROMs, String?>(
      externalName: "romHashSHA1",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.ROMs.romHashSHA1
    )
    
    /// Type information for property ``ROMs/romSize`` (`romSize` column).
    public let romSize = MappedColumn<OpenvgdbSchema.ROMs, Int?>(
      externalName: "romSize",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.ROMs.romSize
    )
    
    /// Type information for property ``ROMs/romFileName`` (`romFileName` column).
    public let romFileName = MappedColumn<OpenvgdbSchema.ROMs, String?>(
      externalName: "romFileName",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.ROMs.romFileName
    )
    
    /// Type information for property ``ROMs/romExtensionlessFileName`` (`romExtensionlessFileName` column).
    public let romExtensionlessFileName = MappedColumn<OpenvgdbSchema.ROMs, String?>(
      externalName: "romExtensionlessFileName",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.ROMs.romExtensionlessFileName
    )
    
    /// Type information for property ``ROMs/romParent`` (`romParent` column).
    public let romParent = MappedColumn<OpenvgdbSchema.ROMs, String?>(
      externalName: "romParent",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.ROMs.romParent
    )
    
    /// Type information for property ``ROMs/romSerial`` (`romSerial` column).
    public let romSerial = MappedColumn<OpenvgdbSchema.ROMs, String?>(
      externalName: "romSerial",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.ROMs.romSerial
    )
    
    /// Type information for property ``ROMs/romHeader`` (`romHeader` column).
    public let romHeader = MappedColumn<OpenvgdbSchema.ROMs, String?>(
      externalName: "romHeader",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.ROMs.romHeader
    )
    
    /// Type information for property ``ROMs/romLanguage`` (`romLanguage` column).
    public let romLanguage = MappedColumn<OpenvgdbSchema.ROMs, String?>(
      externalName: "romLanguage",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.ROMs.romLanguage
    )
    
    /// Type information for property ``ROMs/tEMPromRegion`` (`TEMPromRegion` column).
    public let tEMPromRegion = MappedColumn<OpenvgdbSchema.ROMs, String?>(
      externalName: "TEMPromRegion",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.ROMs.tEMPromRegion
    )
    
    /// Type information for property ``ROMs/romDumpSource`` (`romDumpSource` column).
    public let romDumpSource = MappedColumn<OpenvgdbSchema.ROMs, String?>(
      externalName: "romDumpSource",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.ROMs.romDumpSource
    )
    
    #if swift(>=5.7)
    public var _allColumns : [ any SQLColumn ] { [ id, systemID, regionID, romHashCRC, romHashMD5, romHashSHA1, romSize, romFileName, romExtensionlessFileName, romParent, romSerial, romHeader, romLanguage, tEMPromRegion, romDumpSource ] }
    #endif // swift(>=5.7)
    
    public init()
    {
    }
  }
  
  /**
   * Initialize a ``ROMs`` record from a SQLite statement handle.
   * 
   * This initializer allows easy setup of a record structure from an
   * otherwise arbitrarily constructed SQLite prepared statement.
   * 
   * If no `indices` are specified, the `Schema/lookupColumnIndices`
   * function will be used to find the positions of the structure properties
   * based on their external name.
   * When looping, it is recommended to do the lookup once, and then
   * provide the `indices` to the initializer.
   * 
   * Required values that are missing in the statement are replaced with
   * their assigned default values, i.e. this can even be used to perform
   * partial selects w/ only a minor overhead (the extra space for a
   * record).
   * 
   * Example:
   * ```swift
   * var statement : OpaquePointer?
   * sqlite3_prepare_v2(dbHandle, "SELECT * FROM ROMs", -1, &statement, nil)
   * while sqlite3_step(statement) == SQLITE_ROW {
   *   let record = ROMs(statement)
   *   print("Fetched:", record)
   * }
   * sqlite3_finalize(statement)
   * ```
   * 
   * - Parameters:
   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.
   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).
   */
  @inlinable
  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)
  {
    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)
    let argc = sqlite3_column_count(statement)
    self.init(
      id: (indices.idx_id >= 0) && (indices.idx_id < argc) ? (sqlite3_column_type(statement, indices.idx_id) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_id)) : nil) : Self.schema.id.defaultValue,
      systemID: (indices.idx_systemID >= 0) && (indices.idx_systemID < argc) ? (sqlite3_column_type(statement, indices.idx_systemID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_systemID)) : nil) : Self.schema.systemID.defaultValue,
      regionID: (indices.idx_regionID >= 0) && (indices.idx_regionID < argc) ? (sqlite3_column_type(statement, indices.idx_regionID) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_regionID)) : nil) : Self.schema.regionID.defaultValue,
      romHashCRC: (indices.idx_romHashCRC >= 0) && (indices.idx_romHashCRC < argc) ? (sqlite3_column_text(statement, indices.idx_romHashCRC).flatMap(String.init(cString:))) : Self.schema.romHashCRC.defaultValue,
      romHashMD5: (indices.idx_romHashMD5 >= 0) && (indices.idx_romHashMD5 < argc) ? (sqlite3_column_text(statement, indices.idx_romHashMD5).flatMap(String.init(cString:))) : Self.schema.romHashMD5.defaultValue,
      romHashSHA1: (indices.idx_romHashSHA1 >= 0) && (indices.idx_romHashSHA1 < argc) ? (sqlite3_column_text(statement, indices.idx_romHashSHA1).flatMap(String.init(cString:))) : Self.schema.romHashSHA1.defaultValue,
      romSize: (indices.idx_romSize >= 0) && (indices.idx_romSize < argc) ? (sqlite3_column_type(statement, indices.idx_romSize) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_romSize)) : nil) : Self.schema.romSize.defaultValue,
      romFileName: (indices.idx_romFileName >= 0) && (indices.idx_romFileName < argc) ? (sqlite3_column_text(statement, indices.idx_romFileName).flatMap(String.init(cString:))) : Self.schema.romFileName.defaultValue,
      romExtensionlessFileName: (indices.idx_romExtensionlessFileName >= 0) && (indices.idx_romExtensionlessFileName < argc) ? (sqlite3_column_text(statement, indices.idx_romExtensionlessFileName).flatMap(String.init(cString:))) : Self.schema.romExtensionlessFileName.defaultValue,
      romParent: (indices.idx_romParent >= 0) && (indices.idx_romParent < argc) ? (sqlite3_column_text(statement, indices.idx_romParent).flatMap(String.init(cString:))) : Self.schema.romParent.defaultValue,
      romSerial: (indices.idx_romSerial >= 0) && (indices.idx_romSerial < argc) ? (sqlite3_column_text(statement, indices.idx_romSerial).flatMap(String.init(cString:))) : Self.schema.romSerial.defaultValue,
      romHeader: (indices.idx_romHeader >= 0) && (indices.idx_romHeader < argc) ? (sqlite3_column_text(statement, indices.idx_romHeader).flatMap(String.init(cString:))) : Self.schema.romHeader.defaultValue,
      romLanguage: (indices.idx_romLanguage >= 0) && (indices.idx_romLanguage < argc) ? (sqlite3_column_text(statement, indices.idx_romLanguage).flatMap(String.init(cString:))) : Self.schema.romLanguage.defaultValue,
      tEMPromRegion: (indices.idx_tEMPromRegion >= 0) && (indices.idx_tEMPromRegion < argc) ? (sqlite3_column_text(statement, indices.idx_tEMPromRegion).flatMap(String.init(cString:))) : Self.schema.tEMPromRegion.defaultValue,
      romDumpSource: (indices.idx_romDumpSource >= 0) && (indices.idx_romDumpSource < argc) ? (sqlite3_column_text(statement, indices.idx_romDumpSource).flatMap(String.init(cString:))) : Self.schema.romDumpSource.defaultValue
    )
  }
  
  /**
   * Bind all ``ROMs`` properties to a prepared statement and call a closure.
   * 
   * *Important*: The bindings are only valid within the closure being executed!
   * 
   * Example:
   * ```swift
   * var statement : OpaquePointer?
   * sqlite3_prepare_v2(
   *   dbHandle,
   *   #"UPDATE "ROMs" SET "systemID" = ?, "regionID" = ?, "romHashCRC" = ?, "romHashMD5" = ?, "romHashSHA1" = ?, "romSize" = ?, "romFileName" = ?, "romExtensionlessFileName" = ?, "romParent" = ?, "romSerial" = ?, "romHeader" = ?, "romLanguage" = ?, "TEMPromRegion" = ?, "romDumpSource" = ? WHERE "romID" = ?"#,
   *   -1, &statement, nil
   * )
   * 
   * let record = ROMs(id: 1, systemID: 2, regionID: 3, romHashCRC: "Hello")
   * let ok = record.bind(to: statement, indices: ( 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 )) {
   *   sqlite3_step(statement) == SQLITE_DONE
   * }
   * sqlite3_finalize(statement)
   * ```
   * 
   * - Parameters:
   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.
   *   - indices: The parameter positions for the bindings.
   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!
   * - Returns: Returns the result of the closure that is passed in.
   */
  @inlinable
  @discardableResult
  func bind<R>(
    to statement: OpaquePointer!,
    indices: Schema.PropertyIndices,
    then execute: () throws -> R
  ) rethrows -> R
  {
    if indices.idx_id >= 0 {
      if let id = id {
        sqlite3_bind_int64(statement, indices.idx_id, Int64(id))
      }
      else {
        sqlite3_bind_null(statement, indices.idx_id)
      }
    }
    if indices.idx_systemID >= 0 {
      if let systemID = systemID {
        sqlite3_bind_int64(statement, indices.idx_systemID, Int64(systemID))
      }
      else {
        sqlite3_bind_null(statement, indices.idx_systemID)
      }
    }
    if indices.idx_regionID >= 0 {
      if let regionID = regionID {
        sqlite3_bind_int64(statement, indices.idx_regionID, Int64(regionID))
      }
      else {
        sqlite3_bind_null(statement, indices.idx_regionID)
      }
    }
    return try OpenvgdbSchema.withOptCString(romHashCRC) { ( s ) in
      if indices.idx_romHashCRC >= 0 {
        sqlite3_bind_text(statement, indices.idx_romHashCRC, s, -1, nil)
      }
      return try OpenvgdbSchema.withOptCString(romHashMD5) { ( s ) in
        if indices.idx_romHashMD5 >= 0 {
          sqlite3_bind_text(statement, indices.idx_romHashMD5, s, -1, nil)
        }
        return try OpenvgdbSchema.withOptCString(romHashSHA1) { ( s ) in
          if indices.idx_romHashSHA1 >= 0 {
            sqlite3_bind_text(statement, indices.idx_romHashSHA1, s, -1, nil)
          }
          if indices.idx_romSize >= 0 {
            if let romSize = romSize {
              sqlite3_bind_int64(statement, indices.idx_romSize, Int64(romSize))
            }
            else {
              sqlite3_bind_null(statement, indices.idx_romSize)
            }
          }
          return try OpenvgdbSchema.withOptCString(romFileName) { ( s ) in
            if indices.idx_romFileName >= 0 {
              sqlite3_bind_text(statement, indices.idx_romFileName, s, -1, nil)
            }
            return try OpenvgdbSchema.withOptCString(romExtensionlessFileName) { ( s ) in
              if indices.idx_romExtensionlessFileName >= 0 {
                sqlite3_bind_text(statement, indices.idx_romExtensionlessFileName, s, -1, nil)
              }
              return try OpenvgdbSchema.withOptCString(romParent) { ( s ) in
                if indices.idx_romParent >= 0 {
                  sqlite3_bind_text(statement, indices.idx_romParent, s, -1, nil)
                }
                return try OpenvgdbSchema.withOptCString(romSerial) { ( s ) in
                  if indices.idx_romSerial >= 0 {
                    sqlite3_bind_text(statement, indices.idx_romSerial, s, -1, nil)
                  }
                  return try OpenvgdbSchema.withOptCString(romHeader) { ( s ) in
                    if indices.idx_romHeader >= 0 {
                      sqlite3_bind_text(statement, indices.idx_romHeader, s, -1, nil)
                    }
                    return try OpenvgdbSchema.withOptCString(romLanguage) { ( s ) in
                      if indices.idx_romLanguage >= 0 {
                        sqlite3_bind_text(statement, indices.idx_romLanguage, s, -1, nil)
                      }
                      return try OpenvgdbSchema.withOptCString(tEMPromRegion) { ( s ) in
                        if indices.idx_tEMPromRegion >= 0 {
                          sqlite3_bind_text(statement, indices.idx_tEMPromRegion, s, -1, nil)
                        }
                        return try OpenvgdbSchema.withOptCString(romDumpSource) { ( s ) in
                          if indices.idx_romDumpSource >= 0 {
                            sqlite3_bind_text(statement, indices.idx_romDumpSource, s, -1, nil)
                          }
                          return try execute()
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

public extension OpenvgdbSchema.SYSTEMS {
  
  /**
   * Static type information for the ``SYSTEMS`` record (`SYSTEMS` SQL table).
   * 
   * This structure captures the static SQL information associated with the
   * record.
   * It is used for static type lookups and more.
   */
  struct Schema : SQLKeyedTableSchema, SQLSwiftMatchableSchema {
    
    public typealias PropertyIndices = ( idx_id: Int32, idx_systemName: Int32, idx_systemShortName: Int32, idx_systemHeaderSizeBytes: Int32, idx_systemHashless: Int32, idx_systemHeader: Int32, idx_systemSerial: Int32, idx_systemOEID: Int32 )
    public typealias RecordType = OpenvgdbSchema.SYSTEMS
    public typealias MatchClosureType = ( OpenvgdbSchema.SYSTEMS ) -> Bool
    
    /// The SQL table name associated with the ``SYSTEMS`` record.
    public static let externalName = "SYSTEMS"
    
    /// The number of columns the `SYSTEMS` table has.
    public static let columnCount : Int32 = 8
    
    /// Information on the records primary key (``SYSTEMS/id``).
    public static let primaryKeyColumn = MappedColumn<OpenvgdbSchema.SYSTEMS, Int?>(
      externalName: "systemID",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.SYSTEMS.id
    )
    
    /// SQL to `SELECT` all columns of the `SYSTEMS` table.
    public static let select = #"SELECT "systemID", "systemName", "systemShortName", "systemHeaderSizeBytes", "systemHashless", "systemHeader", "systemSerial", "systemOEID" FROM "SYSTEMS""#
    
    /// SQL fragment representing all columns.
    public static let selectColumns = #""systemID", "systemName", "systemShortName", "systemHeaderSizeBytes", "systemHashless", "systemHeader", "systemSerial", "systemOEID""#
    
    /// Index positions of the properties in ``selectColumns``.
    public static let selectColumnIndices : PropertyIndices = ( 0, 1, 2, 3, 4, 5, 6, 7 )
    
    /// SQL to `SELECT` all columns of the `SYSTEMS` table using a Swift filter.
    public static let matchSelect = #"SELECT "systemID", "systemName", "systemShortName", "systemHeaderSizeBytes", "systemHashless", "systemHeader", "systemSerial", "systemOEID" FROM "SYSTEMS" WHERE sYSTEMS_swift_match("systemID", "systemName", "systemShortName", "systemHeaderSizeBytes", "systemHashless", "systemHeader", "systemSerial", "systemOEID") != 0"#
    
    /// *Note*: Readonly database, do not use.
    public static let update = ""
    
    /// *Note*: Readonly database, do not use.
    public static let updateParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1 )
    
    /// *Note*: Readonly database, do not use.
    public static let insert = ""
    
    /// *Note*: Readonly database, do not use.
    public static let insertReturning = ""
    
    /// *Note*: Readonly database, do not use.
    public static let insertParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1 )
    
    /// *Note*: Readonly database, do not use.
    public static let delete = ""
    
    /// *Note*: Readonly database, do not use.
    public static let deleteParameterIndices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1 )
    
    /**
     * Lookup property indices by column name in a statement handle.
     * 
     * Properties are ordered in the schema and have a specific index
     * assigned.
     * E.g. if the record has two properties, `id` and `name`,
     * and the query was `SELECT age, SYSTEMS_id FROM SYSTEMS`,
     * this would return `( idx_id: 1, idx_name: -1 )`.
     * Because the `SYSTEMS_id` is in the second position and `name`
     * isn't provided at all.
     * 
     * - Parameters:
     *   - statement: A raw SQLite3 prepared statement handle.
     * - Returns: The positions of the properties in the prepared statement.
     */
    @inlinable
    public static func lookupColumnIndices(`in` statement: OpaquePointer!)
      -> PropertyIndices
    {
      var indices : PropertyIndices = ( -1, -1, -1, -1, -1, -1, -1, -1 )
      for i in 0..<sqlite3_column_count(statement) {
        let col = sqlite3_column_name(statement, i)
        if strcmp(col!, "systemID") == 0 {
          indices.idx_id = i
        }
        else if strcmp(col!, "systemName") == 0 {
          indices.idx_systemName = i
        }
        else if strcmp(col!, "systemShortName") == 0 {
          indices.idx_systemShortName = i
        }
        else if strcmp(col!, "systemHeaderSizeBytes") == 0 {
          indices.idx_systemHeaderSizeBytes = i
        }
        else if strcmp(col!, "systemHashless") == 0 {
          indices.idx_systemHashless = i
        }
        else if strcmp(col!, "systemHeader") == 0 {
          indices.idx_systemHeader = i
        }
        else if strcmp(col!, "systemSerial") == 0 {
          indices.idx_systemSerial = i
        }
        else if strcmp(col!, "systemOEID") == 0 {
          indices.idx_systemOEID = i
        }
      }
      return indices
    }
    
    /**
     * Register the Swift matcher function for the ``SYSTEMS`` record.
     * 
     * SQLite Swift matcher functions are used to process `filter` queries
     * and low-level matching w/o the Lighter library.
     * 
     * - Parameters:
     *   - unsafeDatabaseHandle: SQLite3 database handle.
     *   - flags: SQLite3 function registration flags, default: `SQLITE_UTF8`
     *   - matcher: A pointer to the Swift closure used to filter the records.
     * - Returns: The result code of `sqlite3_create_function`, e.g. `SQLITE_OK`.
     */
    @inlinable
    @discardableResult
    public static func registerSwiftMatcher(
      `in` unsafeDatabaseHandle: OpaquePointer!,
      flags: Int32 = SQLITE_UTF8,
      matcher: UnsafeRawPointer
    ) -> Int32
    {
      func dispatch(
        _ context: OpaquePointer?,
        argc: Int32,
        argv: UnsafeMutablePointer<OpaquePointer?>!
      )
      {
        if let closureRawPtr = sqlite3_user_data(context) {
          let closurePtr = closureRawPtr.bindMemory(to: MatchClosureType.self, capacity: 1)
          let indices = OpenvgdbSchema.SYSTEMS.Schema.selectColumnIndices
          let record = OpenvgdbSchema.SYSTEMS(
            id: (indices.idx_id >= 0) && (indices.idx_id < argc) ? (sqlite3_value_type(argv[Int(indices.idx_id)]) != SQLITE_NULL ? Int(sqlite3_value_int64(argv[Int(indices.idx_id)])) : nil) : RecordType.schema.id.defaultValue,
            systemName: (indices.idx_systemName >= 0) && (indices.idx_systemName < argc) ? (sqlite3_value_text(argv[Int(indices.idx_systemName)]).flatMap(String.init(cString:))) : RecordType.schema.systemName.defaultValue,
            systemShortName: (indices.idx_systemShortName >= 0) && (indices.idx_systemShortName < argc) ? (sqlite3_value_text(argv[Int(indices.idx_systemShortName)]).flatMap(String.init(cString:))) : RecordType.schema.systemShortName.defaultValue,
            systemHeaderSizeBytes: (indices.idx_systemHeaderSizeBytes >= 0) && (indices.idx_systemHeaderSizeBytes < argc) ? (sqlite3_value_type(argv[Int(indices.idx_systemHeaderSizeBytes)]) != SQLITE_NULL ? Int(sqlite3_value_int64(argv[Int(indices.idx_systemHeaderSizeBytes)])) : nil) : RecordType.schema.systemHeaderSizeBytes.defaultValue,
            systemHashless: (indices.idx_systemHashless >= 0) && (indices.idx_systemHashless < argc) ? (sqlite3_value_type(argv[Int(indices.idx_systemHashless)]) != SQLITE_NULL ? Int(sqlite3_value_int64(argv[Int(indices.idx_systemHashless)])) : nil) : RecordType.schema.systemHashless.defaultValue,
            systemHeader: (indices.idx_systemHeader >= 0) && (indices.idx_systemHeader < argc) ? (sqlite3_value_type(argv[Int(indices.idx_systemHeader)]) != SQLITE_NULL ? Int(sqlite3_value_int64(argv[Int(indices.idx_systemHeader)])) : nil) : RecordType.schema.systemHeader.defaultValue,
            systemSerial: (indices.idx_systemSerial >= 0) && (indices.idx_systemSerial < argc) ? (sqlite3_value_text(argv[Int(indices.idx_systemSerial)]).flatMap(String.init(cString:))) : RecordType.schema.systemSerial.defaultValue,
            systemOEID: (indices.idx_systemOEID >= 0) && (indices.idx_systemOEID < argc) ? (sqlite3_value_text(argv[Int(indices.idx_systemOEID)]).flatMap(String.init(cString:))) : RecordType.schema.systemOEID.defaultValue
          )
          sqlite3_result_int(context, closurePtr.pointee(record) ? 1 : 0)
        }
        else {
          sqlite3_result_error(context, "Missing Swift matcher closure", -1)
        }
      }
      return sqlite3_create_function(
        unsafeDatabaseHandle,
        "sYSTEMS_swift_match",
        OpenvgdbSchema.SYSTEMS.Schema.columnCount,
        flags,
        UnsafeMutableRawPointer(mutating: matcher),
        dispatch,
        nil,
        nil
      )
    }
    
    /**
     * Unregister the Swift matcher function for the ``SYSTEMS`` record.
     * 
     * SQLite Swift matcher functions are used to process `filter` queries
     * and low-level matching w/o the Lighter library.
     * 
     * - Parameters:
     *   - unsafeDatabaseHandle: SQLite3 database handle.
     *   - flags: SQLite3 function registration flags, default: `SQLITE_UTF8`
     * - Returns: The result code of `sqlite3_create_function`, e.g. `SQLITE_OK`.
     */
    @inlinable
    @discardableResult
    public static func unregisterSwiftMatcher(
      `in` unsafeDatabaseHandle: OpaquePointer!,
      flags: Int32 = SQLITE_UTF8
    ) -> Int32
    {
      sqlite3_create_function(
        unsafeDatabaseHandle,
        "sYSTEMS_swift_match",
        OpenvgdbSchema.SYSTEMS.Schema.columnCount,
        flags,
        nil,
        nil,
        nil,
        nil
      )
    }
    
    /// Type information for property ``SYSTEMS/id`` (`systemID` column).
    public let id = MappedColumn<OpenvgdbSchema.SYSTEMS, Int?>(
      externalName: "systemID",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.SYSTEMS.id
    )
    
    /// Type information for property ``SYSTEMS/systemName`` (`systemName` column).
    public let systemName = MappedColumn<OpenvgdbSchema.SYSTEMS, String?>(
      externalName: "systemName",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.SYSTEMS.systemName
    )
    
    /// Type information for property ``SYSTEMS/systemShortName`` (`systemShortName` column).
    public let systemShortName = MappedColumn<OpenvgdbSchema.SYSTEMS, String?>(
      externalName: "systemShortName",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.SYSTEMS.systemShortName
    )
    
    /// Type information for property ``SYSTEMS/systemHeaderSizeBytes`` (`systemHeaderSizeBytes` column).
    public let systemHeaderSizeBytes = MappedColumn<OpenvgdbSchema.SYSTEMS, Int?>(
      externalName: "systemHeaderSizeBytes",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.SYSTEMS.systemHeaderSizeBytes
    )
    
    /// Type information for property ``SYSTEMS/systemHashless`` (`systemHashless` column).
    public let systemHashless = MappedColumn<OpenvgdbSchema.SYSTEMS, Int?>(
      externalName: "systemHashless",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.SYSTEMS.systemHashless
    )
    
    /// Type information for property ``SYSTEMS/systemHeader`` (`systemHeader` column).
    public let systemHeader = MappedColumn<OpenvgdbSchema.SYSTEMS, Int?>(
      externalName: "systemHeader",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.SYSTEMS.systemHeader
    )
    
    /// Type information for property ``SYSTEMS/systemSerial`` (`systemSerial` column).
    public let systemSerial = MappedColumn<OpenvgdbSchema.SYSTEMS, String?>(
      externalName: "systemSerial",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.SYSTEMS.systemSerial
    )
    
    /// Type information for property ``SYSTEMS/systemOEID`` (`systemOEID` column).
    public let systemOEID = MappedColumn<OpenvgdbSchema.SYSTEMS, String?>(
      externalName: "systemOEID",
      defaultValue: nil,
      keyPath: \OpenvgdbSchema.SYSTEMS.systemOEID
    )
    
    #if swift(>=5.7)
    public var _allColumns : [ any SQLColumn ] { [ id, systemName, systemShortName, systemHeaderSizeBytes, systemHashless, systemHeader, systemSerial, systemOEID ] }
    #endif // swift(>=5.7)
    
    public init()
    {
    }
  }
  
  /**
   * Initialize a ``SYSTEMS`` record from a SQLite statement handle.
   * 
   * This initializer allows easy setup of a record structure from an
   * otherwise arbitrarily constructed SQLite prepared statement.
   * 
   * If no `indices` are specified, the `Schema/lookupColumnIndices`
   * function will be used to find the positions of the structure properties
   * based on their external name.
   * When looping, it is recommended to do the lookup once, and then
   * provide the `indices` to the initializer.
   * 
   * Required values that are missing in the statement are replaced with
   * their assigned default values, i.e. this can even be used to perform
   * partial selects w/ only a minor overhead (the extra space for a
   * record).
   * 
   * Example:
   * ```swift
   * var statement : OpaquePointer?
   * sqlite3_prepare_v2(dbHandle, "SELECT * FROM SYSTEMS", -1, &statement, nil)
   * while sqlite3_step(statement) == SQLITE_ROW {
   *   let record = SYSTEMS(statement)
   *   print("Fetched:", record)
   * }
   * sqlite3_finalize(statement)
   * ```
   * 
   * - Parameters:
   *   - statement: Statement handle as returned by `sqlite3_prepare*` functions.
   *   - indices: Property bindings positions, defaults to `nil` (automatic lookup).
   */
  @inlinable
  init(_ statement: OpaquePointer!, indices: Schema.PropertyIndices? = nil)
  {
    let indices = indices ?? Self.Schema.lookupColumnIndices(in: statement)
    let argc = sqlite3_column_count(statement)
    self.init(
      id: (indices.idx_id >= 0) && (indices.idx_id < argc) ? (sqlite3_column_type(statement, indices.idx_id) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_id)) : nil) : Self.schema.id.defaultValue,
      systemName: (indices.idx_systemName >= 0) && (indices.idx_systemName < argc) ? (sqlite3_column_text(statement, indices.idx_systemName).flatMap(String.init(cString:))) : Self.schema.systemName.defaultValue,
      systemShortName: (indices.idx_systemShortName >= 0) && (indices.idx_systemShortName < argc) ? (sqlite3_column_text(statement, indices.idx_systemShortName).flatMap(String.init(cString:))) : Self.schema.systemShortName.defaultValue,
      systemHeaderSizeBytes: (indices.idx_systemHeaderSizeBytes >= 0) && (indices.idx_systemHeaderSizeBytes < argc) ? (sqlite3_column_type(statement, indices.idx_systemHeaderSizeBytes) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_systemHeaderSizeBytes)) : nil) : Self.schema.systemHeaderSizeBytes.defaultValue,
      systemHashless: (indices.idx_systemHashless >= 0) && (indices.idx_systemHashless < argc) ? (sqlite3_column_type(statement, indices.idx_systemHashless) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_systemHashless)) : nil) : Self.schema.systemHashless.defaultValue,
      systemHeader: (indices.idx_systemHeader >= 0) && (indices.idx_systemHeader < argc) ? (sqlite3_column_type(statement, indices.idx_systemHeader) != SQLITE_NULL ? Int(sqlite3_column_int64(statement, indices.idx_systemHeader)) : nil) : Self.schema.systemHeader.defaultValue,
      systemSerial: (indices.idx_systemSerial >= 0) && (indices.idx_systemSerial < argc) ? (sqlite3_column_text(statement, indices.idx_systemSerial).flatMap(String.init(cString:))) : Self.schema.systemSerial.defaultValue,
      systemOEID: (indices.idx_systemOEID >= 0) && (indices.idx_systemOEID < argc) ? (sqlite3_column_text(statement, indices.idx_systemOEID).flatMap(String.init(cString:))) : Self.schema.systemOEID.defaultValue
    )
  }
  
  /**
   * Bind all ``SYSTEMS`` properties to a prepared statement and call a closure.
   * 
   * *Important*: The bindings are only valid within the closure being executed!
   * 
   * Example:
   * ```swift
   * var statement : OpaquePointer?
   * sqlite3_prepare_v2(
   *   dbHandle,
   *   #"UPDATE "SYSTEMS" SET "systemName" = ?, "systemShortName" = ?, "systemHeaderSizeBytes" = ?, "systemHashless" = ?, "systemHeader" = ?, "systemSerial" = ?, "systemOEID" = ? WHERE "systemID" = ?"#,
   *   -1, &statement, nil
   * )
   * 
   * let record = SYSTEMS(id: 1, systemName: "Hello", systemShortName: "World", systemHeaderSizeBytes: 2)
   * let ok = record.bind(to: statement, indices: ( 8, 1, 2, 3, 4, 5, 6, 7 )) {
   *   sqlite3_step(statement) == SQLITE_DONE
   * }
   * sqlite3_finalize(statement)
   * ```
   * 
   * - Parameters:
   *   - statement: A SQLite3 statement handle as returned by the `sqlite3_prepare*` functions.
   *   - indices: The parameter positions for the bindings.
   *   - execute: Closure executed with bindings applied, bindings _only_ valid within the call!
   * - Returns: Returns the result of the closure that is passed in.
   */
  @inlinable
  @discardableResult
  func bind<R>(
    to statement: OpaquePointer!,
    indices: Schema.PropertyIndices,
    then execute: () throws -> R
  ) rethrows -> R
  {
    if indices.idx_id >= 0 {
      if let id = id {
        sqlite3_bind_int64(statement, indices.idx_id, Int64(id))
      }
      else {
        sqlite3_bind_null(statement, indices.idx_id)
      }
    }
    return try OpenvgdbSchema.withOptCString(systemName) { ( s ) in
      if indices.idx_systemName >= 0 {
        sqlite3_bind_text(statement, indices.idx_systemName, s, -1, nil)
      }
      return try OpenvgdbSchema.withOptCString(systemShortName) { ( s ) in
        if indices.idx_systemShortName >= 0 {
          sqlite3_bind_text(statement, indices.idx_systemShortName, s, -1, nil)
        }
        if indices.idx_systemHeaderSizeBytes >= 0 {
          if let systemHeaderSizeBytes = systemHeaderSizeBytes {
            sqlite3_bind_int64(
              statement,
              indices.idx_systemHeaderSizeBytes,
              Int64(systemHeaderSizeBytes)
            )
          }
          else {
            sqlite3_bind_null(statement, indices.idx_systemHeaderSizeBytes)
          }
        }
        if indices.idx_systemHashless >= 0 {
          if let systemHashless = systemHashless {
            sqlite3_bind_int64(statement, indices.idx_systemHashless, Int64(systemHashless))
          }
          else {
            sqlite3_bind_null(statement, indices.idx_systemHashless)
          }
        }
        if indices.idx_systemHeader >= 0 {
          if let systemHeader = systemHeader {
            sqlite3_bind_int64(statement, indices.idx_systemHeader, Int64(systemHeader))
          }
          else {
            sqlite3_bind_null(statement, indices.idx_systemHeader)
          }
        }
        return try OpenvgdbSchema.withOptCString(systemSerial) { ( s ) in
          if indices.idx_systemSerial >= 0 {
            sqlite3_bind_text(statement, indices.idx_systemSerial, s, -1, nil)
          }
          return try OpenvgdbSchema.withOptCString(systemOEID) { ( s ) in
            if indices.idx_systemOEID >= 0 {
              sqlite3_bind_text(statement, indices.idx_systemOEID, s, -1, nil)
            }
            return try execute()
          }
        }
      }
    }
  }
}
