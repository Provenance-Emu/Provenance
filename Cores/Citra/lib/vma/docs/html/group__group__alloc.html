<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vulkan Memory Allocator: Memory allocation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Vulkan Memory Allocator
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Memory allocation</div></div>
</div><!--header-->
<div class="contents">

<p>API elements related to the allocation, deallocation, and management of Vulkan memory, buffers, images. Most basic ones being: <a class="el" href="#gac72ee55598617e8eecca384e746bab51" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="#ga02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters of new <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a>.  <a href="struct_vma_allocation_create_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_pool_create_info.html">VmaPoolCreateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes parameter of created <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a>.  <a href="struct_vma_pool_create_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_allocation_info2.html">VmaAllocationInfo2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended parameters of a <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a> object that can be retrieved using function <a class="el" href="#ga1405cf3eae2fd1305d645879173031a0" title="Returns extended information about specified allocation.">vmaGetAllocationInfo2()</a>.  <a href="struct_vma_allocation_info2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for defragmentation.  <a href="struct_vma_defragmentation_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_defragmentation_move.html">VmaDefragmentationMove</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single move of an allocation to be done for defragmentation.  <a href="struct_vma_defragmentation_move.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for incremental defragmentation steps.  <a href="struct_vma_defragmentation_pass_move_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_defragmentation_stats.html">VmaDefragmentationStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics returned for defragmentation process in function <a class="el" href="#ga59f01ca3d53d50b7cca9b442b77a3e87" title="Ends defragmentation process.">vmaEndDefragmentation()</a>.  <a href="struct_vma_defragmentation_stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_pool.html">VmaPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents custom memory pool.  <a href="struct_vma_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents single memory allocation.  <a href="struct_vma_allocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque object that represents started defragmentation process.  <a href="struct_vma_defragmentation_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga806e8499dde802e59eb72a1dc811c35f" id="r_ga806e8499dde802e59eb72a1dc811c35f"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#gaa5846affa1e9da3800e3e78fae2305cc">VmaMemoryUsage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga806e8499dde802e59eb72a1dc811c35f">VmaMemoryUsage</a></td></tr>
<tr class="memdesc:ga806e8499dde802e59eb72a1dc811c35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intended usage of the allocated memory.  <br /></td></tr>
<tr class="separator:ga806e8499dde802e59eb72a1dc811c35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fceecc301f4064dc808d3cd6c038941" id="r_ga4fceecc301f4064dc808d3cd6c038941"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#gad9889c10c798b040d59c92f257cae597">VmaAllocationCreateFlagBits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4fceecc301f4064dc808d3cd6c038941">VmaAllocationCreateFlagBits</a></td></tr>
<tr class="memdesc:ga4fceecc301f4064dc808d3cd6c038941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>.  <br /></td></tr>
<tr class="separator:ga4fceecc301f4064dc808d3cd6c038941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5225e5e11f8376f6a31a1791f3d6e817" id="r_ga5225e5e11f8376f6a31a1791f3d6e817"><td class="memItemLeft" align="right" valign="top">typedef VkFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5225e5e11f8376f6a31a1791f3d6e817">VmaAllocationCreateFlags</a></td></tr>
<tr class="memdesc:ga5225e5e11f8376f6a31a1791f3d6e817"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="#gad9889c10c798b040d59c92f257cae597" title="Flags to be passed as VmaAllocationCreateInfo::flags.">VmaAllocationCreateFlagBits</a>.  <br /></td></tr>
<tr class="separator:ga5225e5e11f8376f6a31a1791f3d6e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d4f2efc2509157a9e4ecd4fd7942303" id="r_ga4d4f2efc2509157a9e4ecd4fd7942303"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#ga9a7c45f9c863695d98c83fa5ac940fe7">VmaPoolCreateFlagBits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4d4f2efc2509157a9e4ecd4fd7942303">VmaPoolCreateFlagBits</a></td></tr>
<tr class="memdesc:ga4d4f2efc2509157a9e4ecd4fd7942303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_pool_create_info.html#a8405139f63d078340ae74513a59f5446" title="Use combination of VmaPoolCreateFlagBits.">VmaPoolCreateInfo::flags</a>.  <br /></td></tr>
<tr class="separator:ga4d4f2efc2509157a9e4ecd4fd7942303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2770e325ea42e087c1b91fdf46d0292a" id="r_ga2770e325ea42e087c1b91fdf46d0292a"><td class="memItemLeft" align="right" valign="top">typedef VkFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2770e325ea42e087c1b91fdf46d0292a">VmaPoolCreateFlags</a></td></tr>
<tr class="memdesc:ga2770e325ea42e087c1b91fdf46d0292a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_pool_create_info.html#a8405139f63d078340ae74513a59f5446" title="Use combination of VmaPoolCreateFlagBits.">VmaPoolCreateInfo::flags</a>. See <a class="el" href="#ga9a7c45f9c863695d98c83fa5ac940fe7" title="Flags to be passed as VmaPoolCreateInfo::flags.">VmaPoolCreateFlagBits</a>.  <br /></td></tr>
<tr class="separator:ga2770e325ea42e087c1b91fdf46d0292a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13415cc0b443353a7b5abda300b833fc" id="r_ga13415cc0b443353a7b5abda300b833fc"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#ga6552a65b71d16f378c6994b3ceaef50c">VmaDefragmentationFlagBits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga13415cc0b443353a7b5abda300b833fc">VmaDefragmentationFlagBits</a></td></tr>
<tr class="memdesc:ga13415cc0b443353a7b5abda300b833fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_defragmentation_info.html#a3e23080c978ecf3abb3180f5b2069da7" title="Use combination of VmaDefragmentationFlagBits.">VmaDefragmentationInfo::flags</a>.  <br /></td></tr>
<tr class="separator:ga13415cc0b443353a7b5abda300b833fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88a77cef37e5d3c4fc9eb328885d048d" id="r_ga88a77cef37e5d3c4fc9eb328885d048d"><td class="memItemLeft" align="right" valign="top">typedef VkFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga88a77cef37e5d3c4fc9eb328885d048d">VmaDefragmentationFlags</a></td></tr>
<tr class="memdesc:ga88a77cef37e5d3c4fc9eb328885d048d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="#ga6552a65b71d16f378c6994b3ceaef50c" title="Flags to be passed as VmaDefragmentationInfo::flags.">VmaDefragmentationFlagBits</a>.  <br /></td></tr>
<tr class="separator:ga88a77cef37e5d3c4fc9eb328885d048d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ea666deeb3c2c74806a097e27cdb4a1" id="r_ga2ea666deeb3c2c74806a097e27cdb4a1"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#gada9e3861caf96f08894b0bcc160ec257">VmaDefragmentationMoveOperation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2ea666deeb3c2c74806a097e27cdb4a1">VmaDefragmentationMoveOperation</a></td></tr>
<tr class="memdesc:ga2ea666deeb3c2c74806a097e27cdb4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation performed on single defragmentation move. See structure <a class="el" href="struct_vma_defragmentation_move.html" title="Single move of an allocation to be done for defragmentation.">VmaDefragmentationMove</a>.  <br /></td></tr>
<tr class="separator:ga2ea666deeb3c2c74806a097e27cdb4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bf110892ea2fb4649fedb68488d026a" id="r_ga3bf110892ea2fb4649fedb68488d026a"><td class="memItemLeft" align="right" valign="top">typedef struct VmaAllocationCreateInfo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3bf110892ea2fb4649fedb68488d026a">VmaAllocationCreateInfo</a></td></tr>
<tr class="memdesc:ga3bf110892ea2fb4649fedb68488d026a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters of new <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a>.  <br /></td></tr>
<tr class="separator:ga3bf110892ea2fb4649fedb68488d026a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1017aa83489c0eee8d2163d2bf253f67" id="r_ga1017aa83489c0eee8d2163d2bf253f67"><td class="memItemLeft" align="right" valign="top">typedef struct VmaPoolCreateInfo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1017aa83489c0eee8d2163d2bf253f67">VmaPoolCreateInfo</a></td></tr>
<tr class="memdesc:ga1017aa83489c0eee8d2163d2bf253f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes parameter of created <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a>.  <br /></td></tr>
<tr class="separator:ga1017aa83489c0eee8d2163d2bf253f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf7774606721026a68aabe3af2e5b50" id="r_ga1cf7774606721026a68aabe3af2e5b50"><td class="memItemLeft" align="right" valign="top">typedef struct VmaAllocationInfo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1cf7774606721026a68aabe3af2e5b50">VmaAllocationInfo</a></td></tr>
<tr class="separator:ga1cf7774606721026a68aabe3af2e5b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25ede29f830f326b8572a18ce879bf64" id="r_ga25ede29f830f326b8572a18ce879bf64"><td class="memItemLeft" align="right" valign="top">typedef struct VmaAllocationInfo2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga25ede29f830f326b8572a18ce879bf64">VmaAllocationInfo2</a></td></tr>
<tr class="memdesc:ga25ede29f830f326b8572a18ce879bf64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended parameters of a <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a> object that can be retrieved using function <a class="el" href="#ga1405cf3eae2fd1305d645879173031a0" title="Returns extended information about specified allocation.">vmaGetAllocationInfo2()</a>.  <br /></td></tr>
<tr class="separator:ga25ede29f830f326b8572a18ce879bf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f57b18d4241e80be444842df3094b30" id="r_ga6f57b18d4241e80be444842df3094b30"><td class="memItemLeft" align="right" valign="top">typedef VkBool32(VKAPI_PTR *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6f57b18d4241e80be444842df3094b30">PFN_vmaCheckDefragmentationBreakFunction</a>) (void *pUserData)</td></tr>
<tr class="separator:ga6f57b18d4241e80be444842df3094b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bf47f96bf92bed2a49461bd9af3acfa" id="r_ga2bf47f96bf92bed2a49461bd9af3acfa"><td class="memItemLeft" align="right" valign="top">typedef struct VmaDefragmentationInfo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2bf47f96bf92bed2a49461bd9af3acfa">VmaDefragmentationInfo</a></td></tr>
<tr class="memdesc:ga2bf47f96bf92bed2a49461bd9af3acfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for defragmentation.  <br /></td></tr>
<tr class="separator:ga2bf47f96bf92bed2a49461bd9af3acfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga563f4b43d3e31ed603d80cacc9ba8589" id="r_ga563f4b43d3e31ed603d80cacc9ba8589"><td class="memItemLeft" align="right" valign="top">typedef struct VmaDefragmentationMove&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga563f4b43d3e31ed603d80cacc9ba8589">VmaDefragmentationMove</a></td></tr>
<tr class="memdesc:ga563f4b43d3e31ed603d80cacc9ba8589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single move of an allocation to be done for defragmentation.  <br /></td></tr>
<tr class="separator:ga563f4b43d3e31ed603d80cacc9ba8589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6799e8e2b1527abfc84d33bc44aeaf5" id="r_gad6799e8e2b1527abfc84d33bc44aeaf5"><td class="memItemLeft" align="right" valign="top">typedef struct VmaDefragmentationPassMoveInfo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad6799e8e2b1527abfc84d33bc44aeaf5">VmaDefragmentationPassMoveInfo</a></td></tr>
<tr class="memdesc:gad6799e8e2b1527abfc84d33bc44aeaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for incremental defragmentation steps.  <br /></td></tr>
<tr class="separator:gad6799e8e2b1527abfc84d33bc44aeaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad94034192259c2e34a4d1c5e27810403" id="r_gad94034192259c2e34a4d1c5e27810403"><td class="memItemLeft" align="right" valign="top">typedef struct VmaDefragmentationStats&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad94034192259c2e34a4d1c5e27810403">VmaDefragmentationStats</a></td></tr>
<tr class="memdesc:gad94034192259c2e34a4d1c5e27810403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics returned for defragmentation process in function <a class="el" href="#ga59f01ca3d53d50b7cca9b442b77a3e87" title="Ends defragmentation process.">vmaEndDefragmentation()</a>.  <br /></td></tr>
<tr class="separator:gad94034192259c2e34a4d1c5e27810403"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa5846affa1e9da3800e3e78fae2305cc" id="r_gaa5846affa1e9da3800e3e78fae2305cc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa5846affa1e9da3800e3e78fae2305cc">VmaMemoryUsage</a> { <br />
&#160;&#160;<a class="el" href="#ggaa5846affa1e9da3800e3e78fae2305ccaf50d27e34e0925cf3a63db8c839121dd">VMA_MEMORY_USAGE_UNKNOWN</a> = 0
, <a class="el" href="#ggaa5846affa1e9da3800e3e78fae2305ccac6b5dc1432d88647aa4cd456246eadf7">VMA_MEMORY_USAGE_GPU_ONLY</a> = 1
, <a class="el" href="#ggaa5846affa1e9da3800e3e78fae2305cca40bdf4cddeffeb12f43d45ca1286e0a5">VMA_MEMORY_USAGE_CPU_ONLY</a> = 2
, <a class="el" href="#ggaa5846affa1e9da3800e3e78fae2305cca9066b52c5a7079bb74a69aaf8b92ff67">VMA_MEMORY_USAGE_CPU_TO_GPU</a> = 3
, <br />
&#160;&#160;<a class="el" href="#ggaa5846affa1e9da3800e3e78fae2305cca7b586d2fdaf82a463b58f581ed72be27">VMA_MEMORY_USAGE_GPU_TO_CPU</a> = 4
, <a class="el" href="#ggaa5846affa1e9da3800e3e78fae2305cca416a444d4d0fc20067c3f76f32ff2500">VMA_MEMORY_USAGE_CPU_COPY</a> = 5
, <a class="el" href="#ggaa5846affa1e9da3800e3e78fae2305cca835333d9072db63a653818030e17614d">VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED</a> = 6
, <a class="el" href="#ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e">VMA_MEMORY_USAGE_AUTO</a> = 7
, <br />
&#160;&#160;<a class="el" href="#ggaa5846affa1e9da3800e3e78fae2305ccae2adb696d6a73c18bb20c23666661327">VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE</a> = 8
, <a class="el" href="#ggaa5846affa1e9da3800e3e78fae2305cca9b422585242160b8ed3418310ee6664d">VMA_MEMORY_USAGE_AUTO_PREFER_HOST</a> = 9
, <a class="el" href="#ggaa5846affa1e9da3800e3e78fae2305cca091e69437ef693e8d0d287f1c719ba6e">VMA_MEMORY_USAGE_MAX_ENUM</a> = 0x7FFFFFFF
<br />
 }</td></tr>
<tr class="memdesc:gaa5846affa1e9da3800e3e78fae2305cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intended usage of the allocated memory.  <a href="#gaa5846affa1e9da3800e3e78fae2305cc">More...</a><br /></td></tr>
<tr class="separator:gaa5846affa1e9da3800e3e78fae2305cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9889c10c798b040d59c92f257cae597" id="r_gad9889c10c798b040d59c92f257cae597"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad9889c10c798b040d59c92f257cae597">VmaAllocationCreateFlagBits</a> { <br />
&#160;&#160;<a class="el" href="#ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a> = 0x00000001
, <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</a> = 0x00000002
, <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f">VMA_ALLOCATION_CREATE_MAPPED_BIT</a> = 0x00000004
, <a class="el" href="#ggad9889c10c798b040d59c92f257cae597aa6f24f821cd6a7c5e4a443f7bf59c520">VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</a> = 0x00000020
, <br />
&#160;&#160;<a class="el" href="#ggad9889c10c798b040d59c92f257cae597a42ba3a2d2c7117953210b7c3ef8da0df">VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</a> = 0x00000040
, <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a2310568c62208af432724305fe29ccea">VMA_ALLOCATION_CREATE_DONT_BIND_BIT</a> = 0x00000080
, <a class="el" href="#ggad9889c10c798b040d59c92f257cae597ab8b1764f3e9022368e440c057783b92d">VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT</a> = 0x00000100
, <a class="el" href="#ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6">VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT</a> = 0x00000200
, <br />
&#160;&#160;<a class="el" href="#ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</a> = 0x00000400
, <a class="el" href="#ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</a> = 0x00000800
, <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a11337f96eacf34c1016c339eac165cad">VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</a> = 0x00001000
, <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</a> = 0x00010000
, <br />
&#160;&#160;<a class="el" href="#ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</a> = 0x00020000
, <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d">VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</a> = 0x00040000
, <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a839826775c62319466441f86496f036d">VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</a> = VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT
, <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a33eb2052674f3ad92386c714a65fb777">VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</a> = VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT
, <br />
&#160;&#160;<a class="el" href="#ggad9889c10c798b040d59c92f257cae597a8e16845d81ae3d27c47106d4770d5c7e">VMA_ALLOCATION_CREATE_STRATEGY_MASK</a>
, <a class="el" href="#ggad9889c10c798b040d59c92f257cae597ae5633ec569f4899cf8f29e7385b2f882">VMA_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM</a> = 0x7FFFFFFF
<br />
 }</td></tr>
<tr class="memdesc:gad9889c10c798b040d59c92f257cae597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>.  <a href="#gad9889c10c798b040d59c92f257cae597">More...</a><br /></td></tr>
<tr class="separator:gad9889c10c798b040d59c92f257cae597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a7c45f9c863695d98c83fa5ac940fe7" id="r_ga9a7c45f9c863695d98c83fa5ac940fe7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9a7c45f9c863695d98c83fa5ac940fe7">VmaPoolCreateFlagBits</a> { <a class="el" href="#gga9a7c45f9c863695d98c83fa5ac940fe7a9f1a499508a8edb4e8ba40aa0290a3d2">VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</a> = 0x00000002
, <a class="el" href="#gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</a> = 0x00000004
, <a class="el" href="#gga9a7c45f9c863695d98c83fa5ac940fe7af4d270f8f42517a0f70037ceb6ac1d9c">VMA_POOL_CREATE_ALGORITHM_MASK</a>
, <a class="el" href="#gga9a7c45f9c863695d98c83fa5ac940fe7a1c7312bea9ea246846b9054fd6bd6aec">VMA_POOL_CREATE_FLAG_BITS_MAX_ENUM</a> = 0x7FFFFFFF
 }</td></tr>
<tr class="memdesc:ga9a7c45f9c863695d98c83fa5ac940fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_pool_create_info.html#a8405139f63d078340ae74513a59f5446" title="Use combination of VmaPoolCreateFlagBits.">VmaPoolCreateInfo::flags</a>.  <a href="#ga9a7c45f9c863695d98c83fa5ac940fe7">More...</a><br /></td></tr>
<tr class="separator:ga9a7c45f9c863695d98c83fa5ac940fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6552a65b71d16f378c6994b3ceaef50c" id="r_ga6552a65b71d16f378c6994b3ceaef50c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6552a65b71d16f378c6994b3ceaef50c">VmaDefragmentationFlagBits</a> { <br />
&#160;&#160;<a class="el" href="#gga6552a65b71d16f378c6994b3ceaef50ca2e6469bcf5a094776ceb5d118263f04b">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT</a> = 0x1
, <a class="el" href="#gga6552a65b71d16f378c6994b3ceaef50caec35a4138111605a6ff32ca61aa871b6">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</a> = 0x2
, <a class="el" href="#gga6552a65b71d16f378c6994b3ceaef50cafa162eac5be800bcdd4011427a71156d">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</a> = 0x4
, <a class="el" href="#gga6552a65b71d16f378c6994b3ceaef50cae45a9469e5337731627758671741e412">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</a> = 0x8
, <br />
&#160;&#160;<a class="el" href="#gga6552a65b71d16f378c6994b3ceaef50cabcbbdb3bfd53c4c3ab4eaeb5fd4894e9">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK</a>
, <a class="el" href="#gga6552a65b71d16f378c6994b3ceaef50cab87ec33154803bfeb5ac2b379f1d6a97">VMA_DEFRAGMENTATION_FLAG_BITS_MAX_ENUM</a> = 0x7FFFFFFF
<br />
 }</td></tr>
<tr class="memdesc:ga6552a65b71d16f378c6994b3ceaef50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to be passed as <a class="el" href="struct_vma_defragmentation_info.html#a3e23080c978ecf3abb3180f5b2069da7" title="Use combination of VmaDefragmentationFlagBits.">VmaDefragmentationInfo::flags</a>.  <a href="#ga6552a65b71d16f378c6994b3ceaef50c">More...</a><br /></td></tr>
<tr class="separator:ga6552a65b71d16f378c6994b3ceaef50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada9e3861caf96f08894b0bcc160ec257" id="r_gada9e3861caf96f08894b0bcc160ec257"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gada9e3861caf96f08894b0bcc160ec257">VmaDefragmentationMoveOperation</a> { <a class="el" href="#ggada9e3861caf96f08894b0bcc160ec257ad4a06ac46c4cb1c67b0ebc1edfab9f18">VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY</a> = 0
, <a class="el" href="#ggada9e3861caf96f08894b0bcc160ec257ad25bc6f816b226b4fd5170e845f218d2">VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE</a> = 1
, <a class="el" href="#ggada9e3861caf96f08894b0bcc160ec257a9786f8492a9be2c03bd26395e352ab85">VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY</a> = 2
 }</td></tr>
<tr class="memdesc:gada9e3861caf96f08894b0bcc160ec257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation performed on single defragmentation move. See structure <a class="el" href="struct_vma_defragmentation_move.html" title="Single move of an allocation to be done for defragmentation.">VmaDefragmentationMove</a>.  <a href="#gada9e3861caf96f08894b0bcc160ec257">More...</a><br /></td></tr>
<tr class="separator:gada9e3861caf96f08894b0bcc160ec257"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaef15a94b58fbcb0fe706d5720e84a74a" id="r_gaef15a94b58fbcb0fe706d5720e84a74a"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaef15a94b58fbcb0fe706d5720e84a74a">vmaFindMemoryTypeIndex</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, uint32_t memoryTypeBits, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pAllocationCreateInfo, uint32_t *pMemoryTypeIndex)</td></tr>
<tr class="memdesc:gaef15a94b58fbcb0fe706d5720e84a74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helps to find memoryTypeIndex, given memoryTypeBits and <a class="el" href="struct_vma_allocation_create_info.html" title="Parameters of new VmaAllocation.">VmaAllocationCreateInfo</a>.  <br /></td></tr>
<tr class="separator:gaef15a94b58fbcb0fe706d5720e84a74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae790ab9ffaf7667fb8f62523e6897888" id="r_gae790ab9ffaf7667fb8f62523e6897888"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae790ab9ffaf7667fb8f62523e6897888">vmaFindMemoryTypeIndexForBufferInfo</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const VkBufferCreateInfo *pBufferCreateInfo, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pAllocationCreateInfo, uint32_t *pMemoryTypeIndex)</td></tr>
<tr class="memdesc:gae790ab9ffaf7667fb8f62523e6897888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helps to find memoryTypeIndex, given VkBufferCreateInfo and <a class="el" href="struct_vma_allocation_create_info.html" title="Parameters of new VmaAllocation.">VmaAllocationCreateInfo</a>.  <br /></td></tr>
<tr class="separator:gae790ab9ffaf7667fb8f62523e6897888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga088da83d8eaf3ce9056d9ea0b981d472" id="r_ga088da83d8eaf3ce9056d9ea0b981d472"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga088da83d8eaf3ce9056d9ea0b981d472">vmaFindMemoryTypeIndexForImageInfo</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const VkImageCreateInfo *pImageCreateInfo, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pAllocationCreateInfo, uint32_t *pMemoryTypeIndex)</td></tr>
<tr class="memdesc:ga088da83d8eaf3ce9056d9ea0b981d472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helps to find memoryTypeIndex, given VkImageCreateInfo and <a class="el" href="struct_vma_allocation_create_info.html" title="Parameters of new VmaAllocation.">VmaAllocationCreateInfo</a>.  <br /></td></tr>
<tr class="separator:ga088da83d8eaf3ce9056d9ea0b981d472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c8770ded7c59c8caac6de0c2cb00b50" id="r_ga5c8770ded7c59c8caac6de0c2cb00b50"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5c8770ded7c59c8caac6de0c2cb00b50">vmaCreatePool</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const <a class="el" href="struct_vma_pool_create_info.html">VmaPoolCreateInfo</a> *pCreateInfo, <a class="el" href="struct_vma_pool.html">VmaPool</a> *pPool)</td></tr>
<tr class="memdesc:ga5c8770ded7c59c8caac6de0c2cb00b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates Vulkan device memory and creates <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a> object.  <br /></td></tr>
<tr class="separator:ga5c8770ded7c59c8caac6de0c2cb00b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5485779c8f1948238fc4e92232fa65e1" id="r_ga5485779c8f1948238fc4e92232fa65e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5485779c8f1948238fc4e92232fa65e1">vmaDestroyPool</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_pool.html">VmaPool</a> pool)</td></tr>
<tr class="memdesc:ga5485779c8f1948238fc4e92232fa65e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a> object and frees Vulkan device memory.  <br /></td></tr>
<tr class="separator:ga5485779c8f1948238fc4e92232fa65e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad535935619c7a549bf837e1bb0068f89" id="r_gad535935619c7a549bf837e1bb0068f89"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad535935619c7a549bf837e1bb0068f89">vmaCheckPoolCorruption</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_pool.html">VmaPool</a> pool)</td></tr>
<tr class="memdesc:gad535935619c7a549bf837e1bb0068f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks magic number in margins around all allocations in given memory pool in search for corruptions.  <br /></td></tr>
<tr class="separator:gad535935619c7a549bf837e1bb0068f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf09b4e4eafdbee812e8d73ddf960f030" id="r_gaf09b4e4eafdbee812e8d73ddf960f030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf09b4e4eafdbee812e8d73ddf960f030">vmaGetPoolName</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_pool.html">VmaPool</a> pool, const char **ppName)</td></tr>
<tr class="memdesc:gaf09b4e4eafdbee812e8d73ddf960f030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves name of a custom pool.  <br /></td></tr>
<tr class="separator:gaf09b4e4eafdbee812e8d73ddf960f030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbae3a0b4ab078024462fc85c37f3b58" id="r_gadbae3a0b4ab078024462fc85c37f3b58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadbae3a0b4ab078024462fc85c37f3b58">vmaSetPoolName</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_pool.html">VmaPool</a> pool, const char *pName)</td></tr>
<tr class="memdesc:gadbae3a0b4ab078024462fc85c37f3b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets name of a custom pool.  <br /></td></tr>
<tr class="separator:gadbae3a0b4ab078024462fc85c37f3b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf28077dbf82d0908b8acbe8ee8dd9b8" id="r_gabf28077dbf82d0908b8acbe8ee8dd9b8"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabf28077dbf82d0908b8acbe8ee8dd9b8">vmaAllocateMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const VkMemoryRequirements *pVkMemoryRequirements, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pCreateInfo, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *pAllocationInfo)</td></tr>
<tr class="memdesc:gabf28077dbf82d0908b8acbe8ee8dd9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose memory allocation.  <br /></td></tr>
<tr class="separator:gabf28077dbf82d0908b8acbe8ee8dd9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad37e82e492b3de38fc3f4cffd9ad0ae1" id="r_gad37e82e492b3de38fc3f4cffd9ad0ae1"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad37e82e492b3de38fc3f4cffd9ad0ae1">vmaAllocateMemoryPages</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const VkMemoryRequirements *pVkMemoryRequirements, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pCreateInfo, size_t allocationCount, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocations, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *pAllocationInfo)</td></tr>
<tr class="memdesc:gad37e82e492b3de38fc3f4cffd9ad0ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">General purpose memory allocation for multiple allocation objects at once.  <br /></td></tr>
<tr class="separator:gad37e82e492b3de38fc3f4cffd9ad0ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdf64415b6c3d83c454f28d2c53df7b" id="r_ga7fdf64415b6c3d83c454f28d2c53df7b"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7fdf64415b6c3d83c454f28d2c53df7b">vmaAllocateMemoryForBuffer</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, VkBuffer buffer, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pCreateInfo, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *pAllocationInfo)</td></tr>
<tr class="memdesc:ga7fdf64415b6c3d83c454f28d2c53df7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory suitable for given <code>VkBuffer</code>.  <br /></td></tr>
<tr class="separator:ga7fdf64415b6c3d83c454f28d2c53df7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0faa3f9e5fb233d29d1e00390650febb" id="r_ga0faa3f9e5fb233d29d1e00390650febb"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0faa3f9e5fb233d29d1e00390650febb">vmaAllocateMemoryForImage</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, VkImage image, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pCreateInfo, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *pAllocationInfo)</td></tr>
<tr class="memdesc:ga0faa3f9e5fb233d29d1e00390650febb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory suitable for given <code>VkImage</code>.  <br /></td></tr>
<tr class="separator:ga0faa3f9e5fb233d29d1e00390650febb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fea5518972ae9094b1526cbcb19b05f" id="r_ga5fea5518972ae9094b1526cbcb19b05f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5fea5518972ae9094b1526cbcb19b05f">vmaFreeMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation)</td></tr>
<tr class="memdesc:ga5fea5518972ae9094b1526cbcb19b05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory previously allocated using <a class="el" href="#gabf28077dbf82d0908b8acbe8ee8dd9b8" title="General purpose memory allocation.">vmaAllocateMemory()</a>, <a class="el" href="#ga7fdf64415b6c3d83c454f28d2c53df7b" title="Allocates memory suitable for given VkBuffer.">vmaAllocateMemoryForBuffer()</a>, or <a class="el" href="#ga0faa3f9e5fb233d29d1e00390650febb" title="Allocates memory suitable for given VkImage.">vmaAllocateMemoryForImage()</a>.  <br /></td></tr>
<tr class="separator:ga5fea5518972ae9094b1526cbcb19b05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga834b1e4aef395c0a1d56a28e69a4a17e" id="r_ga834b1e4aef395c0a1d56a28e69a4a17e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga834b1e4aef395c0a1d56a28e69a4a17e">vmaFreeMemoryPages</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, size_t allocationCount, const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocations)</td></tr>
<tr class="memdesc:ga834b1e4aef395c0a1d56a28e69a4a17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory and destroys multiple allocations.  <br /></td></tr>
<tr class="separator:ga834b1e4aef395c0a1d56a28e69a4a17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86dd08aba8633bfa4ad0df2e76481d8b" id="r_ga86dd08aba8633bfa4ad0df2e76481d8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga86dd08aba8633bfa4ad0df2e76481d8b">vmaGetAllocationInfo</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *pAllocationInfo)</td></tr>
<tr class="memdesc:ga86dd08aba8633bfa4ad0df2e76481d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current information about specified allocation.  <br /></td></tr>
<tr class="separator:ga86dd08aba8633bfa4ad0df2e76481d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1405cf3eae2fd1305d645879173031a0" id="r_ga1405cf3eae2fd1305d645879173031a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1405cf3eae2fd1305d645879173031a0">vmaGetAllocationInfo2</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, <a class="el" href="struct_vma_allocation_info2.html">VmaAllocationInfo2</a> *pAllocationInfo)</td></tr>
<tr class="memdesc:ga1405cf3eae2fd1305d645879173031a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns extended information about specified allocation.  <br /></td></tr>
<tr class="separator:ga1405cf3eae2fd1305d645879173031a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9147d31ffc11d62fc187bde283ed14f" id="r_gaf9147d31ffc11d62fc187bde283ed14f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf9147d31ffc11d62fc187bde283ed14f">vmaSetAllocationUserData</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, void *pUserData)</td></tr>
<tr class="memdesc:gaf9147d31ffc11d62fc187bde283ed14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pUserData in given allocation to new value.  <br /></td></tr>
<tr class="separator:gaf9147d31ffc11d62fc187bde283ed14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe02cbb0cd913b3f125958179f2020fc" id="r_gabe02cbb0cd913b3f125958179f2020fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabe02cbb0cd913b3f125958179f2020fc">vmaSetAllocationName</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, const char *pName)</td></tr>
<tr class="memdesc:gabe02cbb0cd913b3f125958179f2020fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pName in given allocation to new value.  <br /></td></tr>
<tr class="separator:gabe02cbb0cd913b3f125958179f2020fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga571e87dd38e552249b56b1b0b982fad1" id="r_ga571e87dd38e552249b56b1b0b982fad1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga571e87dd38e552249b56b1b0b982fad1">vmaGetAllocationMemoryProperties</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, VkMemoryPropertyFlags *pFlags)</td></tr>
<tr class="memdesc:ga571e87dd38e552249b56b1b0b982fad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an allocation, returns Property Flags of its memory type.  <br /></td></tr>
<tr class="separator:ga571e87dd38e552249b56b1b0b982fad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d327b7458d8cf426b84b5efba9bb9bf" id="r_ga8d327b7458d8cf426b84b5efba9bb9bf"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8d327b7458d8cf426b84b5efba9bb9bf">vmaGetMemoryWin32Handle</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, HANDLE hTargetProcess, HANDLE *pHandle)</td></tr>
<tr class="memdesc:ga8d327b7458d8cf426b84b5efba9bb9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an allocation, returns Win32 handle that may be imported by other processes or APIs.  <br /></td></tr>
<tr class="separator:ga8d327b7458d8cf426b84b5efba9bb9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5bd1243512d099706de88168992f069" id="r_gad5bd1243512d099706de88168992f069"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad5bd1243512d099706de88168992f069">vmaMapMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, void **ppData)</td></tr>
<tr class="memdesc:gad5bd1243512d099706de88168992f069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps memory represented by given allocation and returns pointer to it.  <br /></td></tr>
<tr class="separator:gad5bd1243512d099706de88168992f069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bc268595cb33f6ec4d519cfce81ff45" id="r_ga9bc268595cb33f6ec4d519cfce81ff45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9bc268595cb33f6ec4d519cfce81ff45">vmaUnmapMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation)</td></tr>
<tr class="memdesc:ga9bc268595cb33f6ec4d519cfce81ff45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps memory represented by given allocation, mapped previously using <a class="el" href="#gad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>.  <br /></td></tr>
<tr class="separator:ga9bc268595cb33f6ec4d519cfce81ff45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30c37c1eec6025f397be41644f48490f" id="r_ga30c37c1eec6025f397be41644f48490f"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga30c37c1eec6025f397be41644f48490f">vmaFlushAllocation</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, VkDeviceSize offset, VkDeviceSize size)</td></tr>
<tr class="memdesc:ga30c37c1eec6025f397be41644f48490f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes memory of given allocation.  <br /></td></tr>
<tr class="separator:ga30c37c1eec6025f397be41644f48490f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8412919139ef413a4215ac6a290fae" id="r_gaaa8412919139ef413a4215ac6a290fae"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaa8412919139ef413a4215ac6a290fae">vmaInvalidateAllocation</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, VkDeviceSize offset, VkDeviceSize size)</td></tr>
<tr class="memdesc:gaaa8412919139ef413a4215ac6a290fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates memory of given allocation.  <br /></td></tr>
<tr class="separator:gaaa8412919139ef413a4215ac6a290fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3dd00da721875ed99fa8a881922bdfc" id="r_gac3dd00da721875ed99fa8a881922bdfc"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac3dd00da721875ed99fa8a881922bdfc">vmaFlushAllocations</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, uint32_t allocationCount, const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *allocations, const VkDeviceSize *offsets, const VkDeviceSize *sizes)</td></tr>
<tr class="memdesc:gac3dd00da721875ed99fa8a881922bdfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes memory of given set of allocations.  <br /></td></tr>
<tr class="separator:gac3dd00da721875ed99fa8a881922bdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab25b558d75f7378ec944a1522fdcc3c5" id="r_gab25b558d75f7378ec944a1522fdcc3c5"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab25b558d75f7378ec944a1522fdcc3c5">vmaInvalidateAllocations</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, uint32_t allocationCount, const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *allocations, const VkDeviceSize *offsets, const VkDeviceSize *sizes)</td></tr>
<tr class="memdesc:gab25b558d75f7378ec944a1522fdcc3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates memory of given set of allocations.  <br /></td></tr>
<tr class="separator:gab25b558d75f7378ec944a1522fdcc3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11731ec58a3a43a22bb925e0780ef405" id="r_ga11731ec58a3a43a22bb925e0780ef405"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga11731ec58a3a43a22bb925e0780ef405">vmaCopyMemoryToAllocation</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const void *pSrcHostPointer, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> dstAllocation, VkDeviceSize dstAllocationLocalOffset, VkDeviceSize size)</td></tr>
<tr class="memdesc:ga11731ec58a3a43a22bb925e0780ef405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the allocation temporarily if needed, copies data from specified host pointer to it, and flushes the memory from the host caches if needed.  <br /></td></tr>
<tr class="separator:ga11731ec58a3a43a22bb925e0780ef405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac883dd38863944335071213b9ae8477" id="r_gaac883dd38863944335071213b9ae8477"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaac883dd38863944335071213b9ae8477">vmaCopyAllocationToMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> srcAllocation, VkDeviceSize srcAllocationLocalOffset, void *pDstHostPointer, VkDeviceSize size)</td></tr>
<tr class="memdesc:gaac883dd38863944335071213b9ae8477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates memory in the host caches if needed, maps the allocation temporarily if needed, and copies data from it to a specified host pointer.  <br /></td></tr>
<tr class="separator:gaac883dd38863944335071213b9ae8477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49329a7f030dafcf82f7b73334c22e98" id="r_ga49329a7f030dafcf82f7b73334c22e98"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga49329a7f030dafcf82f7b73334c22e98">vmaCheckCorruption</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, uint32_t memoryTypeBits)</td></tr>
<tr class="memdesc:ga49329a7f030dafcf82f7b73334c22e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions.  <br /></td></tr>
<tr class="separator:ga49329a7f030dafcf82f7b73334c22e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3335566858b45541fa9c0d7a6bbb57e" id="r_gac3335566858b45541fa9c0d7a6bbb57e"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac3335566858b45541fa9c0d7a6bbb57e">vmaBeginDefragmentation</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const <a class="el" href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a> *pInfo, <a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> *pContext)</td></tr>
<tr class="memdesc:gac3335566858b45541fa9c0d7a6bbb57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins defragmentation process.  <br /></td></tr>
<tr class="separator:gac3335566858b45541fa9c0d7a6bbb57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59f01ca3d53d50b7cca9b442b77a3e87" id="r_ga59f01ca3d53d50b7cca9b442b77a3e87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga59f01ca3d53d50b7cca9b442b77a3e87">vmaEndDefragmentation</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> context, <a class="el" href="struct_vma_defragmentation_stats.html">VmaDefragmentationStats</a> *pStats)</td></tr>
<tr class="memdesc:ga59f01ca3d53d50b7cca9b442b77a3e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends defragmentation process.  <br /></td></tr>
<tr class="separator:ga59f01ca3d53d50b7cca9b442b77a3e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga980d7da2ce3b1fd5c8b8476bc362cc00" id="r_ga980d7da2ce3b1fd5c8b8476bc362cc00"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga980d7da2ce3b1fd5c8b8476bc362cc00">vmaBeginDefragmentationPass</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> context, <a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a> *pPassInfo)</td></tr>
<tr class="memdesc:ga980d7da2ce3b1fd5c8b8476bc362cc00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts single defragmentation pass.  <br /></td></tr>
<tr class="separator:ga980d7da2ce3b1fd5c8b8476bc362cc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaded05a445742a00718ee766144c5c226" id="r_gaded05a445742a00718ee766144c5c226"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaded05a445742a00718ee766144c5c226">vmaEndDefragmentationPass</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> context, <a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a> *pPassInfo)</td></tr>
<tr class="memdesc:gaded05a445742a00718ee766144c5c226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends single defragmentation pass.  <br /></td></tr>
<tr class="separator:gaded05a445742a00718ee766144c5c226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b0929b914b60cf2d45cac4bf3547470" id="r_ga6b0929b914b60cf2d45cac4bf3547470"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6b0929b914b60cf2d45cac4bf3547470">vmaBindBufferMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, VkBuffer buffer)</td></tr>
<tr class="memdesc:ga6b0929b914b60cf2d45cac4bf3547470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds buffer to allocation.  <br /></td></tr>
<tr class="separator:ga6b0929b914b60cf2d45cac4bf3547470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga861f4f27189a7d11ab9d9eedc825cb6b" id="r_ga861f4f27189a7d11ab9d9eedc825cb6b"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga861f4f27189a7d11ab9d9eedc825cb6b">vmaBindBufferMemory2</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, VkDeviceSize allocationLocalOffset, VkBuffer buffer, const void *(VkBindBufferMemoryInfoKHR) pNext)</td></tr>
<tr class="memdesc:ga861f4f27189a7d11ab9d9eedc825cb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds buffer to allocation with additional parameters.  <br /></td></tr>
<tr class="separator:ga861f4f27189a7d11ab9d9eedc825cb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d3ca45799923aa5d138e9e5f9eb2da5" id="r_ga3d3ca45799923aa5d138e9e5f9eb2da5"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3d3ca45799923aa5d138e9e5f9eb2da5">vmaBindImageMemory</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, VkImage image)</td></tr>
<tr class="memdesc:ga3d3ca45799923aa5d138e9e5f9eb2da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds image to allocation.  <br /></td></tr>
<tr class="separator:ga3d3ca45799923aa5d138e9e5f9eb2da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f3502dd7d38b53fb1533ea3921d038d" id="r_ga5f3502dd7d38b53fb1533ea3921d038d"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5f3502dd7d38b53fb1533ea3921d038d">vmaBindImageMemory2</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, VkDeviceSize allocationLocalOffset, VkImage image, const void *(VkBindImageMemoryInfoKHR) pNext)</td></tr>
<tr class="memdesc:ga5f3502dd7d38b53fb1533ea3921d038d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds image to allocation with additional parameters.  <br /></td></tr>
<tr class="separator:ga5f3502dd7d38b53fb1533ea3921d038d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac72ee55598617e8eecca384e746bab51" id="r_gac72ee55598617e8eecca384e746bab51"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac72ee55598617e8eecca384e746bab51">vmaCreateBuffer</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const VkBufferCreateInfo *pBufferCreateInfo, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pAllocationCreateInfo, VkBuffer *pBuffer, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *pAllocationInfo)</td></tr>
<tr class="memdesc:gac72ee55598617e8eecca384e746bab51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code>VkBuffer</code>, allocates and binds memory for it.  <br /></td></tr>
<tr class="separator:gac72ee55598617e8eecca384e746bab51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa06a690013a0d01e60894ac378083834" id="r_gaa06a690013a0d01e60894ac378083834"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa06a690013a0d01e60894ac378083834">vmaCreateBufferWithAlignment</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const VkBufferCreateInfo *pBufferCreateInfo, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pAllocationCreateInfo, VkDeviceSize minAlignment, VkBuffer *pBuffer, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *pAllocationInfo)</td></tr>
<tr class="memdesc:gaa06a690013a0d01e60894ac378083834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a buffer with additional minimum alignment.  <br /></td></tr>
<tr class="separator:gaa06a690013a0d01e60894ac378083834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60d5d4803e3c82505a2bfddb929adb03" id="r_ga60d5d4803e3c82505a2bfddb929adb03"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga60d5d4803e3c82505a2bfddb929adb03">vmaCreateAliasingBuffer</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, const VkBufferCreateInfo *pBufferCreateInfo, VkBuffer *pBuffer)</td></tr>
<tr class="memdesc:ga60d5d4803e3c82505a2bfddb929adb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code>VkBuffer</code>, binds already created memory for it.  <br /></td></tr>
<tr class="separator:ga60d5d4803e3c82505a2bfddb929adb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0cf014344213e117bd9f9cf5f928122" id="r_gaf0cf014344213e117bd9f9cf5f928122"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf0cf014344213e117bd9f9cf5f928122">vmaCreateAliasingBuffer2</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, VkDeviceSize allocationLocalOffset, const VkBufferCreateInfo *pBufferCreateInfo, VkBuffer *pBuffer)</td></tr>
<tr class="memdesc:gaf0cf014344213e117bd9f9cf5f928122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code>VkBuffer</code>, binds already created memory for it.  <br /></td></tr>
<tr class="separator:gaf0cf014344213e117bd9f9cf5f928122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9f4e4ba5bf9aab1f1c746387753d77" id="r_ga0d9f4e4ba5bf9aab1f1c746387753d77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0d9f4e4ba5bf9aab1f1c746387753d77">vmaDestroyBuffer</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, VkBuffer buffer, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation)</td></tr>
<tr class="memdesc:ga0d9f4e4ba5bf9aab1f1c746387753d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys Vulkan buffer and frees allocated memory.  <br /></td></tr>
<tr class="separator:ga0d9f4e4ba5bf9aab1f1c746387753d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02a94f25679275851a53e82eacbcfc73" id="r_ga02a94f25679275851a53e82eacbcfc73"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga02a94f25679275851a53e82eacbcfc73">vmaCreateImage</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, const VkImageCreateInfo *pImageCreateInfo, const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *pAllocationCreateInfo, VkImage *pImage, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *pAllocation, <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *pAllocationInfo)</td></tr>
<tr class="memdesc:ga02a94f25679275851a53e82eacbcfc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function similar to <a class="el" href="#gac72ee55598617e8eecca384e746bab51" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>.  <br /></td></tr>
<tr class="separator:ga02a94f25679275851a53e82eacbcfc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebc4db1f94b53dba2338b4c0fd80d0dc" id="r_gaebc4db1f94b53dba2338b4c0fd80d0dc"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaebc4db1f94b53dba2338b4c0fd80d0dc">vmaCreateAliasingImage</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, const VkImageCreateInfo *pImageCreateInfo, VkImage *pImage)</td></tr>
<tr class="memdesc:gaebc4db1f94b53dba2338b4c0fd80d0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function similar to <a class="el" href="#ga60d5d4803e3c82505a2bfddb929adb03" title="Creates a new VkBuffer, binds already created memory for it.">vmaCreateAliasingBuffer()</a> but for images.  <br /></td></tr>
<tr class="separator:gaebc4db1f94b53dba2338b4c0fd80d0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69ac829f5bb0737449fa92c2d971f1bb" id="r_ga69ac829f5bb0737449fa92c2d971f1bb"><td class="memItemLeft" align="right" valign="top">VkResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga69ac829f5bb0737449fa92c2d971f1bb">vmaCreateAliasingImage2</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation, VkDeviceSize allocationLocalOffset, const VkImageCreateInfo *pImageCreateInfo, VkImage *pImage)</td></tr>
<tr class="memdesc:ga69ac829f5bb0737449fa92c2d971f1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function similar to <a class="el" href="#gaf0cf014344213e117bd9f9cf5f928122" title="Creates a new VkBuffer, binds already created memory for it.">vmaCreateAliasingBuffer2()</a> but for images.  <br /></td></tr>
<tr class="separator:ga69ac829f5bb0737449fa92c2d971f1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae50d2cb3b4a3bfd4dd40987234e50e7e" id="r_gae50d2cb3b4a3bfd4dd40987234e50e7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae50d2cb3b4a3bfd4dd40987234e50e7e">vmaDestroyImage</a> (<a class="el" href="struct_vma_allocator.html">VmaAllocator</a> allocator, VkImage image, <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> allocation)</td></tr>
<tr class="memdesc:gae50d2cb3b4a3bfd4dd40987234e50e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys Vulkan image and frees allocated memory.  <br /></td></tr>
<tr class="separator:gae50d2cb3b4a3bfd4dd40987234e50e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>API elements related to the allocation, deallocation, and management of Vulkan memory, buffers, images. Most basic ones being: <a class="el" href="#gac72ee55598617e8eecca384e746bab51" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="#ga02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga6f57b18d4241e80be444842df3094b30" name="ga6f57b18d4241e80be444842df3094b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f57b18d4241e80be444842df3094b30">&#9670;&#160;</a></span>PFN_vmaCheckDefragmentationBreakFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VkBool32(VKAPI_PTR * PFN_vmaCheckDefragmentationBreakFunction) (void *pUserData)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function called during <a class="el" href="#gac3335566858b45541fa9c0d7a6bbb57e" title="Begins defragmentation process.">vmaBeginDefragmentation()</a> to check custom criterion about ending current defragmentation pass.</p>
<p>Should return true if the defragmentation needs to stop current pass. </p>

</div>
</div>
<a id="ga4fceecc301f4064dc808d3cd6c038941" name="ga4fceecc301f4064dc808d3cd6c038941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fceecc301f4064dc808d3cd6c038941">&#9670;&#160;</a></span>VmaAllocationCreateFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#gad9889c10c798b040d59c92f257cae597">VmaAllocationCreateFlagBits</a> <a class="el" href="#gad9889c10c798b040d59c92f257cae597">VmaAllocationCreateFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be passed as <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>. </p>

</div>
</div>
<a id="ga5225e5e11f8376f6a31a1791f3d6e817" name="ga5225e5e11f8376f6a31a1791f3d6e817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5225e5e11f8376f6a31a1791f3d6e817">&#9670;&#160;</a></span>VmaAllocationCreateFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VkFlags <a class="el" href="#ga5225e5e11f8376f6a31a1791f3d6e817">VmaAllocationCreateFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="#gad9889c10c798b040d59c92f257cae597" title="Flags to be passed as VmaAllocationCreateInfo::flags.">VmaAllocationCreateFlagBits</a>. </p>

</div>
</div>
<a id="ga3bf110892ea2fb4649fedb68488d026a" name="ga3bf110892ea2fb4649fedb68488d026a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bf110892ea2fb4649fedb68488d026a">&#9670;&#160;</a></span>VmaAllocationCreateInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct VmaAllocationCreateInfo VmaAllocationCreateInfo</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameters of new <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a>. </p>
<p>To be used with functions like <a class="el" href="#gac72ee55598617e8eecca384e746bab51" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="#ga02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>, and many others. </p>

</div>
</div>
<a id="ga1cf7774606721026a68aabe3af2e5b50" name="ga1cf7774606721026a68aabe3af2e5b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cf7774606721026a68aabe3af2e5b50">&#9670;&#160;</a></span>VmaAllocationInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct VmaAllocationInfo VmaAllocationInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters of <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a> objects, that can be retrieved using function <a class="el" href="#ga86dd08aba8633bfa4ad0df2e76481d8b" title="Returns current information about specified allocation.">vmaGetAllocationInfo()</a>.</p>
<p>There is also an extended version of this structure that carries additional parameters: <a class="el" href="struct_vma_allocation_info2.html" title="Extended parameters of a VmaAllocation object that can be retrieved using function vmaGetAllocationIn...">VmaAllocationInfo2</a>. </p>

</div>
</div>
<a id="ga25ede29f830f326b8572a18ce879bf64" name="ga25ede29f830f326b8572a18ce879bf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25ede29f830f326b8572a18ce879bf64">&#9670;&#160;</a></span>VmaAllocationInfo2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct VmaAllocationInfo2 VmaAllocationInfo2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extended parameters of a <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a> object that can be retrieved using function <a class="el" href="#ga1405cf3eae2fd1305d645879173031a0" title="Returns extended information about specified allocation.">vmaGetAllocationInfo2()</a>. </p>

</div>
</div>
<a id="ga13415cc0b443353a7b5abda300b833fc" name="ga13415cc0b443353a7b5abda300b833fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13415cc0b443353a7b5abda300b833fc">&#9670;&#160;</a></span>VmaDefragmentationFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#ga6552a65b71d16f378c6994b3ceaef50c">VmaDefragmentationFlagBits</a> <a class="el" href="#ga6552a65b71d16f378c6994b3ceaef50c">VmaDefragmentationFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be passed as <a class="el" href="struct_vma_defragmentation_info.html#a3e23080c978ecf3abb3180f5b2069da7" title="Use combination of VmaDefragmentationFlagBits.">VmaDefragmentationInfo::flags</a>. </p>

</div>
</div>
<a id="ga88a77cef37e5d3c4fc9eb328885d048d" name="ga88a77cef37e5d3c4fc9eb328885d048d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88a77cef37e5d3c4fc9eb328885d048d">&#9670;&#160;</a></span>VmaDefragmentationFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VkFlags <a class="el" href="#ga88a77cef37e5d3c4fc9eb328885d048d">VmaDefragmentationFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="#ga6552a65b71d16f378c6994b3ceaef50c" title="Flags to be passed as VmaDefragmentationInfo::flags.">VmaDefragmentationFlagBits</a>. </p>

</div>
</div>
<a id="ga2bf47f96bf92bed2a49461bd9af3acfa" name="ga2bf47f96bf92bed2a49461bd9af3acfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bf47f96bf92bed2a49461bd9af3acfa">&#9670;&#160;</a></span>VmaDefragmentationInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct VmaDefragmentationInfo VmaDefragmentationInfo</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameters for defragmentation. </p>
<p>To be used with function <a class="el" href="#gac3335566858b45541fa9c0d7a6bbb57e" title="Begins defragmentation process.">vmaBeginDefragmentation()</a>. </p>

</div>
</div>
<a id="ga563f4b43d3e31ed603d80cacc9ba8589" name="ga563f4b43d3e31ed603d80cacc9ba8589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga563f4b43d3e31ed603d80cacc9ba8589">&#9670;&#160;</a></span>VmaDefragmentationMove</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct VmaDefragmentationMove VmaDefragmentationMove</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single move of an allocation to be done for defragmentation. </p>

</div>
</div>
<a id="ga2ea666deeb3c2c74806a097e27cdb4a1" name="ga2ea666deeb3c2c74806a097e27cdb4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ea666deeb3c2c74806a097e27cdb4a1">&#9670;&#160;</a></span>VmaDefragmentationMoveOperation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#gada9e3861caf96f08894b0bcc160ec257">VmaDefragmentationMoveOperation</a> <a class="el" href="#gada9e3861caf96f08894b0bcc160ec257">VmaDefragmentationMoveOperation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operation performed on single defragmentation move. See structure <a class="el" href="struct_vma_defragmentation_move.html" title="Single move of an allocation to be done for defragmentation.">VmaDefragmentationMove</a>. </p>

</div>
</div>
<a id="gad6799e8e2b1527abfc84d33bc44aeaf5" name="gad6799e8e2b1527abfc84d33bc44aeaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6799e8e2b1527abfc84d33bc44aeaf5">&#9670;&#160;</a></span>VmaDefragmentationPassMoveInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct VmaDefragmentationPassMoveInfo VmaDefragmentationPassMoveInfo</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameters for incremental defragmentation steps. </p>
<p>To be used with function <a class="el" href="#ga980d7da2ce3b1fd5c8b8476bc362cc00" title="Starts single defragmentation pass.">vmaBeginDefragmentationPass()</a>. </p>

</div>
</div>
<a id="gad94034192259c2e34a4d1c5e27810403" name="gad94034192259c2e34a4d1c5e27810403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad94034192259c2e34a4d1c5e27810403">&#9670;&#160;</a></span>VmaDefragmentationStats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct VmaDefragmentationStats VmaDefragmentationStats</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statistics returned for defragmentation process in function <a class="el" href="#ga59f01ca3d53d50b7cca9b442b77a3e87" title="Ends defragmentation process.">vmaEndDefragmentation()</a>. </p>

</div>
</div>
<a id="ga806e8499dde802e59eb72a1dc811c35f" name="ga806e8499dde802e59eb72a1dc811c35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga806e8499dde802e59eb72a1dc811c35f">&#9670;&#160;</a></span>VmaMemoryUsage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#gaa5846affa1e9da3800e3e78fae2305cc">VmaMemoryUsage</a> <a class="el" href="#gaa5846affa1e9da3800e3e78fae2305cc">VmaMemoryUsage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intended usage of the allocated memory. </p>

</div>
</div>
<a id="ga4d4f2efc2509157a9e4ecd4fd7942303" name="ga4d4f2efc2509157a9e4ecd4fd7942303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d4f2efc2509157a9e4ecd4fd7942303">&#9670;&#160;</a></span>VmaPoolCreateFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#ga9a7c45f9c863695d98c83fa5ac940fe7">VmaPoolCreateFlagBits</a> <a class="el" href="#ga9a7c45f9c863695d98c83fa5ac940fe7">VmaPoolCreateFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be passed as <a class="el" href="struct_vma_pool_create_info.html#a8405139f63d078340ae74513a59f5446" title="Use combination of VmaPoolCreateFlagBits.">VmaPoolCreateInfo::flags</a>. </p>

</div>
</div>
<a id="ga2770e325ea42e087c1b91fdf46d0292a" name="ga2770e325ea42e087c1b91fdf46d0292a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2770e325ea42e087c1b91fdf46d0292a">&#9670;&#160;</a></span>VmaPoolCreateFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VkFlags <a class="el" href="#ga2770e325ea42e087c1b91fdf46d0292a">VmaPoolCreateFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be passed as <a class="el" href="struct_vma_pool_create_info.html#a8405139f63d078340ae74513a59f5446" title="Use combination of VmaPoolCreateFlagBits.">VmaPoolCreateInfo::flags</a>. See <a class="el" href="#ga9a7c45f9c863695d98c83fa5ac940fe7" title="Flags to be passed as VmaPoolCreateInfo::flags.">VmaPoolCreateFlagBits</a>. </p>

</div>
</div>
<a id="ga1017aa83489c0eee8d2163d2bf253f67" name="ga1017aa83489c0eee8d2163d2bf253f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1017aa83489c0eee8d2163d2bf253f67">&#9670;&#160;</a></span>VmaPoolCreateInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct VmaPoolCreateInfo VmaPoolCreateInfo</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes parameter of created <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gad9889c10c798b040d59c92f257cae597" name="gad9889c10c798b040d59c92f257cae597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9889c10c798b040d59c92f257cae597">&#9670;&#160;</a></span>VmaAllocationCreateFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gad9889c10c798b040d59c92f257cae597">VmaAllocationCreateFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be passed as <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" name="ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f"></a>VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT&#160;</td><td class="fielddoc"><p>Set this flag if the allocation should have its own memory block. </p>
<p>Use it for special, big resources, like fullscreen images used as attachments.</p>
<p>If you use this flag while creating a buffer or an image, <code>VkMemoryDedicatedAllocateInfo</code> structure is applied if possible. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" name="ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff"></a>VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT&#160;</td><td class="fielddoc"><p>Set this flag to only try to allocate from existing <code>VkDeviceMemory</code> blocks and never create new such block. </p>
<p>If new allocation cannot be placed in any of the existing blocks, allocation fails with <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code> error.</p>
<p>You should not use <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" title="Set this flag if the allocation should have its own memory block.">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a> and <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" title="Set this flag to only try to allocate from existing VkDeviceMemory blocks and never create new such b...">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</a> at the same time. It makes no sense. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" name="ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f"></a>VMA_ALLOCATION_CREATE_MAPPED_BIT&#160;</td><td class="fielddoc"><p>Set this flag to use a memory that will be persistently mapped and retrieve pointer to it. </p>
<p>Pointer to mapped memory will be returned through <a class="el" href="struct_vma_allocation_info.html#a5eeffbe2d2f30f53370ff14aefbadbe2" title="Pointer to the beginning of this allocation as mapped data.">VmaAllocationInfo::pMappedData</a>.</p>
<p>It is valid to use this flag for allocation made from memory type that is not <code>HOST_VISIBLE</code>. This flag is then ignored and memory is not mapped. This is useful if you need an allocation that is efficient to use on GPU (<code>DEVICE_LOCAL</code>) and still want to map it directly if possible on platforms that support it (e.g. Intel GPU). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597aa6f24f821cd6a7c5e4a443f7bf59c520" name="ggad9889c10c798b040d59c92f257cae597aa6f24f821cd6a7c5e4a443f7bf59c520"></a>VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT&#160;</td><td class="fielddoc"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated</a></b></dt><dd>Preserved for backward compatibility. Consider using <a class="el" href="#gabe02cbb0cd913b3f125958179f2020fc" title="Sets pName in given allocation to new value.">vmaSetAllocationName()</a> instead.</dd></dl>
<p>Set this flag to treat <a class="el" href="struct_vma_allocation_create_info.html#a8259e85c272683434f4abb4ddddffe19" title="Custom general-purpose pointer that will be stored in VmaAllocation, can be read as VmaAllocationInfo...">VmaAllocationCreateInfo::pUserData</a> as pointer to a null-terminated string. Instead of copying pointer value, a local copy of the string is made and stored in allocation's <code>pName</code>. The string is automatically freed together with the allocation. It is also used in <a class="el" href="group__group__stats.html#gaa4fee7eb5253377599ef4fd38c93c2a0" title="Builds and returns statistics as a null-terminated string in JSON format.">vmaBuildStatsString()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a42ba3a2d2c7117953210b7c3ef8da0df" name="ggad9889c10c798b040d59c92f257cae597a42ba3a2d2c7117953210b7c3ef8da0df"></a>VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT&#160;</td><td class="fielddoc"><p>Allocation will be created from upper stack in a double stack pool.</p>
<p>This flag is only allowed for custom pools created with <a class="el" href="#gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" title="Enables alternative, linear allocation algorithm in this pool.">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</a> flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a2310568c62208af432724305fe29ccea" name="ggad9889c10c798b040d59c92f257cae597a2310568c62208af432724305fe29ccea"></a>VMA_ALLOCATION_CREATE_DONT_BIND_BIT&#160;</td><td class="fielddoc"><p>Create both buffer/image and allocation, but don't bind them together. It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with functions that bind by default: <a class="el" href="#gac72ee55598617e8eecca384e746bab51" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="#ga02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>. Otherwise it is ignored.</p>
<p>If you want to make sure the new buffer/image is not tied to the new memory allocation through <code>VkMemoryDedicatedAllocateInfoKHR</code> structure in case the allocation ends up in its own memory block, use also flag <a class="el" href="#ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6" title="Set this flag if the allocated memory will have aliasing resources.">VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597ab8b1764f3e9022368e440c057783b92d" name="ggad9889c10c798b040d59c92f257cae597ab8b1764f3e9022368e440c057783b92d"></a>VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT&#160;</td><td class="fielddoc"><p>Create allocation only if additional device memory required for it, if any, won't exceed memory budget. Otherwise return <code>VK_ERROR_OUT_OF_DEVICE_MEMORY</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6" name="ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6"></a>VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT&#160;</td><td class="fielddoc"><p>Set this flag if the allocated memory will have aliasing resources. </p>
<p>Usage of this flag prevents supplying <code>VkMemoryDedicatedAllocateInfoKHR</code> when <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" title="Set this flag if the allocation should have its own memory block.">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a> is specified. Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" name="ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5"></a>VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT&#160;</td><td class="fielddoc"><p>Requests possibility to map the allocation (using <a class="el" href="#gad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a> or <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a>).</p>
<ul>
<li>If you use <a class="el" href="#ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e">VMA_MEMORY_USAGE_AUTO</a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation. Otherwise, mapping is incorrect.</li>
<li>If you use other value of <a class="el" href="#gaa5846affa1e9da3800e3e78fae2305cc" title="Intended usage of the allocated memory.">VmaMemoryUsage</a>, this flag is ignored and mapping is always possible in memory types that are <code>HOST_VISIBLE</code>. This includes allocations created in <a class="el" href="custom_memory_pools.html">Custom memory pools</a>.</li>
</ul>
<p>Declares that mapped memory will only be written sequentially, e.g. using <code>memcpy()</code> or a loop writing number-by-number, never read or accessed randomly, so a memory type can be selected that is uncached and write-combined.</p>
<dl class="section warning"><dt>Warning</dt><dd>Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g. <code>pMappedData[i] += x;</code> Better prepare your data in a local variable and <code>memcpy()</code> it to the mapped pointer all at once. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" name="ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492"></a>VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT&#160;</td><td class="fielddoc"><p>Requests possibility to map the allocation (using <a class="el" href="#gad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a> or <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a>).</p>
<ul>
<li>If you use <a class="el" href="#ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e">VMA_MEMORY_USAGE_AUTO</a> or other <code>VMA_MEMORY_USAGE_AUTO*</code> value, you must use this flag to be able to map the allocation. Otherwise, mapping is incorrect.</li>
<li>If you use other value of <a class="el" href="#gaa5846affa1e9da3800e3e78fae2305cc" title="Intended usage of the allocated memory.">VmaMemoryUsage</a>, this flag is ignored and mapping is always possible in memory types that are <code>HOST_VISIBLE</code>. This includes allocations created in <a class="el" href="custom_memory_pools.html">Custom memory pools</a>.</li>
</ul>
<p>Declares that mapped memory can be read, written, and accessed in random order, so a <code>HOST_CACHED</code> memory type is preferred. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a11337f96eacf34c1016c339eac165cad" name="ggad9889c10c798b040d59c92f257cae597a11337f96eacf34c1016c339eac165cad"></a>VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT&#160;</td><td class="fielddoc"><p>Together with <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</a> or <a class="el" href="#ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</a>, it says that despite request for host access, a not-<code>HOST_VISIBLE</code> memory type can be selected if it may improve performance.</p>
<p>By using this flag, you declare that you will check if the allocation ended up in a <code>HOST_VISIBLE</code> memory type (e.g. using <a class="el" href="#ga571e87dd38e552249b56b1b0b982fad1" title="Given an allocation, returns Property Flags of its memory type.">vmaGetAllocationMemoryProperties()</a>) and if not, you will create some "staging" buffer and issue an explicit transfer to write/read your data. To prepare for this possibility, don't forget to add appropriate flags like <code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code>, <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> to the parameters of created buffer or image. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d" name="ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d"></a>VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT&#160;</td><td class="fielddoc"><p>Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the expense of allocation time. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d" name="ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d"></a>VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT&#160;</td><td class="fielddoc"><p>Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d" name="ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d"></a>VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT&#160;</td><td class="fielddoc"><p>Allocation strategy that chooses always the lowest offset in available space. This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recommended in typical usage. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a839826775c62319466441f86496f036d" name="ggad9889c10c798b040d59c92f257cae597a839826775c62319466441f86496f036d"></a>VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT&#160;</td><td class="fielddoc"><p>Alias to <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a33eb2052674f3ad92386c714a65fb777" name="ggad9889c10c798b040d59c92f257cae597a33eb2052674f3ad92386c714a65fb777"></a>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT&#160;</td><td class="fielddoc"><p>Alias to <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597a8e16845d81ae3d27c47106d4770d5c7e" name="ggad9889c10c798b040d59c92f257cae597a8e16845d81ae3d27c47106d4770d5c7e"></a>VMA_ALLOCATION_CREATE_STRATEGY_MASK&#160;</td><td class="fielddoc"><p>A bit mask to extract only <code>STRATEGY</code> bits from entire set of flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad9889c10c798b040d59c92f257cae597ae5633ec569f4899cf8f29e7385b2f882" name="ggad9889c10c798b040d59c92f257cae597ae5633ec569f4899cf8f29e7385b2f882"></a>VMA_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga6552a65b71d16f378c6994b3ceaef50c" name="ga6552a65b71d16f378c6994b3ceaef50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6552a65b71d16f378c6994b3ceaef50c">&#9670;&#160;</a></span>VmaDefragmentationFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga6552a65b71d16f378c6994b3ceaef50c">VmaDefragmentationFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be passed as <a class="el" href="struct_vma_defragmentation_info.html#a3e23080c978ecf3abb3180f5b2069da7" title="Use combination of VmaDefragmentationFlagBits.">VmaDefragmentationInfo::flags</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6552a65b71d16f378c6994b3ceaef50ca2e6469bcf5a094776ceb5d118263f04b" name="gga6552a65b71d16f378c6994b3ceaef50ca2e6469bcf5a094776ceb5d118263f04b"></a>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga6552a65b71d16f378c6994b3ceaef50caec35a4138111605a6ff32ca61aa871b6" name="gga6552a65b71d16f378c6994b3ceaef50caec35a4138111605a6ff32ca61aa871b6"></a>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga6552a65b71d16f378c6994b3ceaef50cafa162eac5be800bcdd4011427a71156d" name="gga6552a65b71d16f378c6994b3ceaef50cafa162eac5be800bcdd4011427a71156d"></a>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga6552a65b71d16f378c6994b3ceaef50cae45a9469e5337731627758671741e412" name="gga6552a65b71d16f378c6994b3ceaef50cae45a9469e5337731627758671741e412"></a>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT&#160;</td><td class="fielddoc"><p>Use the most roboust algorithm at the cost of time to compute and number of copies to make. Only available when bufferImageGranularity is greater than 1, since it aims to reduce alignment issues between different types of resources. Otherwise falls back to same behavior as <a class="el" href="#gga6552a65b71d16f378c6994b3ceaef50cafa162eac5be800bcdd4011427a71156d">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6552a65b71d16f378c6994b3ceaef50cabcbbdb3bfd53c4c3ab4eaeb5fd4894e9" name="gga6552a65b71d16f378c6994b3ceaef50cabcbbdb3bfd53c4c3ab4eaeb5fd4894e9"></a>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK&#160;</td><td class="fielddoc"><p>A bit mask to extract only <code>ALGORITHM</code> bits from entire set of flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6552a65b71d16f378c6994b3ceaef50cab87ec33154803bfeb5ac2b379f1d6a97" name="gga6552a65b71d16f378c6994b3ceaef50cab87ec33154803bfeb5ac2b379f1d6a97"></a>VMA_DEFRAGMENTATION_FLAG_BITS_MAX_ENUM&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="gada9e3861caf96f08894b0bcc160ec257" name="gada9e3861caf96f08894b0bcc160ec257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada9e3861caf96f08894b0bcc160ec257">&#9670;&#160;</a></span>VmaDefragmentationMoveOperation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gada9e3861caf96f08894b0bcc160ec257">VmaDefragmentationMoveOperation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operation performed on single defragmentation move. See structure <a class="el" href="struct_vma_defragmentation_move.html" title="Single move of an allocation to be done for defragmentation.">VmaDefragmentationMove</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggada9e3861caf96f08894b0bcc160ec257ad4a06ac46c4cb1c67b0ebc1edfab9f18" name="ggada9e3861caf96f08894b0bcc160ec257ad4a06ac46c4cb1c67b0ebc1edfab9f18"></a>VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY&#160;</td><td class="fielddoc"><p>Buffer/image has been recreated at <code>dstTmpAllocation</code>, data has been copied, old buffer/image has been destroyed. <code>srcAllocation</code> should be changed to point to the new place. This is the default value set by <a class="el" href="#ga980d7da2ce3b1fd5c8b8476bc362cc00" title="Starts single defragmentation pass.">vmaBeginDefragmentationPass()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada9e3861caf96f08894b0bcc160ec257ad25bc6f816b226b4fd5170e845f218d2" name="ggada9e3861caf96f08894b0bcc160ec257ad25bc6f816b226b4fd5170e845f218d2"></a>VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE&#160;</td><td class="fielddoc"><p>Set this value if you cannot move the allocation. New place reserved at <code>dstTmpAllocation</code> will be freed. <code>srcAllocation</code> will remain unchanged. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada9e3861caf96f08894b0bcc160ec257a9786f8492a9be2c03bd26395e352ab85" name="ggada9e3861caf96f08894b0bcc160ec257a9786f8492a9be2c03bd26395e352ab85"></a>VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY&#160;</td><td class="fielddoc"><p>Set this value if you decide to abandon the allocation and you destroyed the buffer/image. New place reserved at <code>dstTmpAllocation</code> will be freed, along with <code>srcAllocation</code>, which will be destroyed. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa5846affa1e9da3800e3e78fae2305cc" name="gaa5846affa1e9da3800e3e78fae2305cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5846affa1e9da3800e3e78fae2305cc">&#9670;&#160;</a></span>VmaMemoryUsage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gaa5846affa1e9da3800e3e78fae2305cc">VmaMemoryUsage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intended usage of the allocated memory. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305ccaf50d27e34e0925cf3a63db8c839121dd" name="ggaa5846affa1e9da3800e3e78fae2305ccaf50d27e34e0925cf3a63db8c839121dd"></a>VMA_MEMORY_USAGE_UNKNOWN&#160;</td><td class="fielddoc"><p>No intended memory usage specified. Use other members of <a class="el" href="struct_vma_allocation_create_info.html" title="Parameters of new VmaAllocation.">VmaAllocationCreateInfo</a> to specify your requirements. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305ccac6b5dc1432d88647aa4cd456246eadf7" name="ggaa5846affa1e9da3800e3e78fae2305ccac6b5dc1432d88647aa4cd456246eadf7"></a>VMA_MEMORY_USAGE_GPU_ONLY&#160;</td><td class="fielddoc"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated</a></b></dt><dd>Obsolete, preserved for backward compatibility. Prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305cca40bdf4cddeffeb12f43d45ca1286e0a5" name="ggaa5846affa1e9da3800e3e78fae2305cca40bdf4cddeffeb12f43d45ca1286e0a5"></a>VMA_MEMORY_USAGE_CPU_ONLY&#160;</td><td class="fielddoc"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated</a></b></dt><dd>Obsolete, preserved for backward compatibility. Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305cca9066b52c5a7079bb74a69aaf8b92ff67" name="ggaa5846affa1e9da3800e3e78fae2305cca9066b52c5a7079bb74a69aaf8b92ff67"></a>VMA_MEMORY_USAGE_CPU_TO_GPU&#160;</td><td class="fielddoc"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated</a></b></dt><dd>Obsolete, preserved for backward compatibility. Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305cca7b586d2fdaf82a463b58f581ed72be27" name="ggaa5846affa1e9da3800e3e78fae2305cca7b586d2fdaf82a463b58f581ed72be27"></a>VMA_MEMORY_USAGE_GPU_TO_CPU&#160;</td><td class="fielddoc"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated</a></b></dt><dd>Obsolete, preserved for backward compatibility. Guarantees <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>, prefers <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305cca416a444d4d0fc20067c3f76f32ff2500" name="ggaa5846affa1e9da3800e3e78fae2305cca416a444d4d0fc20067c3f76f32ff2500"></a>VMA_MEMORY_USAGE_CPU_COPY&#160;</td><td class="fielddoc"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated</a></b></dt><dd>Obsolete, preserved for backward compatibility. Prefers not <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305cca835333d9072db63a653818030e17614d" name="ggaa5846affa1e9da3800e3e78fae2305cca835333d9072db63a653818030e17614d"></a>VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED&#160;</td><td class="fielddoc"><p>Lazily allocated GPU memory having <code>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>. Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.</p>
<p>Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with <code>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>.</p>
<p>Allocations with this usage are always created as dedicated - it implies <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" title="Set this flag if the allocation should have its own memory block.">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e" name="ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e"></a>VMA_MEMORY_USAGE_AUTO&#160;</td><td class="fielddoc"><p>Selects best memory type automatically. This flag is recommended for most common use cases.</p>
<p>When using this flag, if you want to map the allocation (using <a class="el" href="#gad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a> or <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a>), you must pass one of the flags: <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</a> or <a class="el" href="#ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</a> in <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>.</p>
<p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a class="el" href="#gac72ee55598617e8eecca384e746bab51" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="#ga02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>, <a class="el" href="#gae790ab9ffaf7667fb8f62523e6897888" title="Helps to find memoryTypeIndex, given VkBufferCreateInfo and VmaAllocationCreateInfo.">vmaFindMemoryTypeIndexForBufferInfo()</a>, <a class="el" href="#ga088da83d8eaf3ce9056d9ea0b981d472" title="Helps to find memoryTypeIndex, given VkImageCreateInfo and VmaAllocationCreateInfo.">vmaFindMemoryTypeIndexForImageInfo()</a> and not with generic memory allocation functions. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305ccae2adb696d6a73c18bb20c23666661327" name="ggaa5846affa1e9da3800e3e78fae2305ccae2adb696d6a73c18bb20c23666661327"></a>VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE&#160;</td><td class="fielddoc"><p>Selects best memory type automatically with preference for GPU (device) memory.</p>
<p>When using this flag, if you want to map the allocation (using <a class="el" href="#gad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a> or <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a>), you must pass one of the flags: <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</a> or <a class="el" href="#ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</a> in <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>.</p>
<p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a class="el" href="#gac72ee55598617e8eecca384e746bab51" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="#ga02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>, <a class="el" href="#gae790ab9ffaf7667fb8f62523e6897888" title="Helps to find memoryTypeIndex, given VkBufferCreateInfo and VmaAllocationCreateInfo.">vmaFindMemoryTypeIndexForBufferInfo()</a>, <a class="el" href="#ga088da83d8eaf3ce9056d9ea0b981d472" title="Helps to find memoryTypeIndex, given VkImageCreateInfo and VmaAllocationCreateInfo.">vmaFindMemoryTypeIndexForImageInfo()</a> and not with generic memory allocation functions. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305cca9b422585242160b8ed3418310ee6664d" name="ggaa5846affa1e9da3800e3e78fae2305cca9b422585242160b8ed3418310ee6664d"></a>VMA_MEMORY_USAGE_AUTO_PREFER_HOST&#160;</td><td class="fielddoc"><p>Selects best memory type automatically with preference for CPU (host) memory.</p>
<p>When using this flag, if you want to map the allocation (using <a class="el" href="#gad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a> or <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a>), you must pass one of the flags: <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</a> or <a class="el" href="#ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</a> in <a class="el" href="struct_vma_allocation_create_info.html#add09658ac14fe290ace25470ddd6d41b" title="Use VmaAllocationCreateFlagBits enum.">VmaAllocationCreateInfo::flags</a>.</p>
<p>It can be used only with functions that let the library know <code>VkBufferCreateInfo</code> or <code>VkImageCreateInfo</code>, e.g. <a class="el" href="#gac72ee55598617e8eecca384e746bab51" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="#ga02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>, <a class="el" href="#gae790ab9ffaf7667fb8f62523e6897888" title="Helps to find memoryTypeIndex, given VkBufferCreateInfo and VmaAllocationCreateInfo.">vmaFindMemoryTypeIndexForBufferInfo()</a>, <a class="el" href="#ga088da83d8eaf3ce9056d9ea0b981d472" title="Helps to find memoryTypeIndex, given VkImageCreateInfo and VmaAllocationCreateInfo.">vmaFindMemoryTypeIndexForImageInfo()</a> and not with generic memory allocation functions. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5846affa1e9da3800e3e78fae2305cca091e69437ef693e8d0d287f1c719ba6e" name="ggaa5846affa1e9da3800e3e78fae2305cca091e69437ef693e8d0d287f1c719ba6e"></a>VMA_MEMORY_USAGE_MAX_ENUM&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga9a7c45f9c863695d98c83fa5ac940fe7" name="ga9a7c45f9c863695d98c83fa5ac940fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a7c45f9c863695d98c83fa5ac940fe7">&#9670;&#160;</a></span>VmaPoolCreateFlagBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga9a7c45f9c863695d98c83fa5ac940fe7">VmaPoolCreateFlagBits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to be passed as <a class="el" href="struct_vma_pool_create_info.html#a8405139f63d078340ae74513a59f5446" title="Use combination of VmaPoolCreateFlagBits.">VmaPoolCreateInfo::flags</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9a7c45f9c863695d98c83fa5ac940fe7a9f1a499508a8edb4e8ba40aa0290a3d2" name="gga9a7c45f9c863695d98c83fa5ac940fe7a9f1a499508a8edb4e8ba40aa0290a3d2"></a>VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT&#160;</td><td class="fielddoc"><p>Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be ignored. </p>
<p>This is an optional optimization flag.</p>
<p>If you always allocate using <a class="el" href="#gac72ee55598617e8eecca384e746bab51" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="#ga02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>, <a class="el" href="#ga7fdf64415b6c3d83c454f28d2c53df7b" title="Allocates memory suitable for given VkBuffer.">vmaAllocateMemoryForBuffer()</a>, then you don't need to use it because allocator knows exact type of your allocations so it can handle Buffer-Image Granularity in the optimal way.</p>
<p>If you also allocate using <a class="el" href="#ga0faa3f9e5fb233d29d1e00390650febb" title="Allocates memory suitable for given VkImage.">vmaAllocateMemoryForImage()</a> or <a class="el" href="#gabf28077dbf82d0908b8acbe8ee8dd9b8" title="General purpose memory allocation.">vmaAllocateMemory()</a>, exact type of such allocations is not known, so allocator must be conservative in handling Buffer-Image Granularity, which can lead to suboptimal allocation (wasted memory). In that case, if you can make sure you always allocate only buffers and linear images or only optimal images out of this pool, use this flag to make allocator disregard Buffer-Image Granularity and so make allocations faster and more optimal. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" name="gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726"></a>VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT&#160;</td><td class="fielddoc"><p>Enables alternative, linear allocation algorithm in this pool. </p>
<p>Specify this flag to enable linear allocation algorithm, which always creates new allocations after last one and doesn't reuse space from allocations freed in between. It trades memory consumption for simplified algorithm and data structure, which has better performance and uses less memory for metadata.</p>
<p>By using this flag, you can achieve behavior of free-at-once, stack, ring buffer, and double stack. For details, see documentation chapter <a class="el" href="custom_memory_pools.html#linear_algorithm">Linear allocation algorithm</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a7c45f9c863695d98c83fa5ac940fe7af4d270f8f42517a0f70037ceb6ac1d9c" name="gga9a7c45f9c863695d98c83fa5ac940fe7af4d270f8f42517a0f70037ceb6ac1d9c"></a>VMA_POOL_CREATE_ALGORITHM_MASK&#160;</td><td class="fielddoc"><p>Bit mask to extract only <code>ALGORITHM</code> bits from entire set of flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9a7c45f9c863695d98c83fa5ac940fe7a1c7312bea9ea246846b9054fd6bd6aec" name="gga9a7c45f9c863695d98c83fa5ac940fe7a1c7312bea9ea246846b9054fd6bd6aec"></a>VMA_POOL_CREATE_FLAG_BITS_MAX_ENUM&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabf28077dbf82d0908b8acbe8ee8dd9b8" name="gabf28077dbf82d0908b8acbe8ee8dd9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf28077dbf82d0908b8acbe8ee8dd9b8">&#9670;&#160;</a></span>vmaAllocateMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaAllocateMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkMemoryRequirements *</td>          <td class="paramname"><span class="paramname"><em>pVkMemoryRequirements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocationInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General purpose memory allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pVkMemoryRequirements</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pCreateInfo</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocation</td><td>Handle to allocated memory. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocationInfo</td><td>Optional. Information about allocated memory. It can be later fetched using function <a class="el" href="#ga86dd08aba8633bfa4ad0df2e76481d8b" title="Returns current information about specified allocation.">vmaGetAllocationInfo()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>You should free the memory using <a class="el" href="#ga5fea5518972ae9094b1526cbcb19b05f" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a> or <a class="el" href="#ga834b1e4aef395c0a1d56a28e69a4a17e" title="Frees memory and destroys multiple allocations.">vmaFreeMemoryPages()</a>.</p>
<p>It is recommended to use <a class="el" href="#ga7fdf64415b6c3d83c454f28d2c53df7b" title="Allocates memory suitable for given VkBuffer.">vmaAllocateMemoryForBuffer()</a>, <a class="el" href="#ga0faa3f9e5fb233d29d1e00390650febb" title="Allocates memory suitable for given VkImage.">vmaAllocateMemoryForImage()</a>, <a class="el" href="#gac72ee55598617e8eecca384e746bab51" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="#ga02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a> instead whenever possible. </p>

</div>
</div>
<a id="ga7fdf64415b6c3d83c454f28d2c53df7b" name="ga7fdf64415b6c3d83c454f28d2c53df7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fdf64415b6c3d83c454f28d2c53df7b">&#9670;&#160;</a></span>vmaAllocateMemoryForBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaAllocateMemoryForBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocationInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory suitable for given <code>VkBuffer</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pCreateInfo</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocation</td><td>Handle to allocated memory. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocationInfo</td><td>Optional. Information about allocated memory. It can be later fetched using function <a class="el" href="#ga86dd08aba8633bfa4ad0df2e76481d8b" title="Returns current information about specified allocation.">vmaGetAllocationInfo()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>It only creates <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a>. To bind the memory to the buffer, use <a class="el" href="#ga6b0929b914b60cf2d45cac4bf3547470" title="Binds buffer to allocation.">vmaBindBufferMemory()</a>.</p>
<p>This is a special-purpose function. In most cases you should use <a class="el" href="#gac72ee55598617e8eecca384e746bab51" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>.</p>
<p>You must free the allocation using <a class="el" href="#ga5fea5518972ae9094b1526cbcb19b05f" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a> when no longer needed. </p>

</div>
</div>
<a id="ga0faa3f9e5fb233d29d1e00390650febb" name="ga0faa3f9e5fb233d29d1e00390650febb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0faa3f9e5fb233d29d1e00390650febb">&#9670;&#160;</a></span>vmaAllocateMemoryForImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaAllocateMemoryForImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage</td>          <td class="paramname"><span class="paramname"><em>image</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocationInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory suitable for given <code>VkImage</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">image</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pCreateInfo</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocation</td><td>Handle to allocated memory. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocationInfo</td><td>Optional. Information about allocated memory. It can be later fetched using function <a class="el" href="#ga86dd08aba8633bfa4ad0df2e76481d8b" title="Returns current information about specified allocation.">vmaGetAllocationInfo()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>It only creates <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a>. To bind the memory to the buffer, use <a class="el" href="#ga3d3ca45799923aa5d138e9e5f9eb2da5" title="Binds image to allocation.">vmaBindImageMemory()</a>.</p>
<p>This is a special-purpose function. In most cases you should use <a class="el" href="#ga02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>.</p>
<p>You must free the allocation using <a class="el" href="#ga5fea5518972ae9094b1526cbcb19b05f" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a> when no longer needed. </p>

</div>
</div>
<a id="gad37e82e492b3de38fc3f4cffd9ad0ae1" name="gad37e82e492b3de38fc3f4cffd9ad0ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad37e82e492b3de38fc3f4cffd9ad0ae1">&#9670;&#160;</a></span>vmaAllocateMemoryPages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaAllocateMemoryPages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkMemoryRequirements *</td>          <td class="paramname"><span class="paramname"><em>pVkMemoryRequirements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>allocationCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocationInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General purpose memory allocation for multiple allocation objects at once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pVkMemoryRequirements</td><td>Memory requirements for each allocation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pCreateInfo</td><td>Creation parameters for each allocation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocationCount</td><td>Number of allocations to make. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocations</td><td>Pointer to array that will be filled with handles to created allocations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocationInfo</td><td>Optional. Pointer to array that will be filled with parameters of created allocations.</td></tr>
  </table>
  </dd>
</dl>
<p>You should free the memory using <a class="el" href="#ga5fea5518972ae9094b1526cbcb19b05f" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a> or <a class="el" href="#ga834b1e4aef395c0a1d56a28e69a4a17e" title="Frees memory and destroys multiple allocations.">vmaFreeMemoryPages()</a>.</p>
<p>Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding. It is just a general purpose allocation function able to make multiple allocations at once. It may be internally optimized to be more efficient than calling <a class="el" href="#gabf28077dbf82d0908b8acbe8ee8dd9b8" title="General purpose memory allocation.">vmaAllocateMemory()</a> <code>allocationCount</code> times.</p>
<p>All allocations are made using same parameters. All of them are created out of the same memory pool and type. If any allocation fails, all allocations already made within this function call are also freed, so that when returned result is not <code>VK_SUCCESS</code>, <code>pAllocation</code> array is always entirely filled with <code>VK_NULL_HANDLE</code>. </p>

</div>
</div>
<a id="gac3335566858b45541fa9c0d7a6bbb57e" name="gac3335566858b45541fa9c0d7a6bbb57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3335566858b45541fa9c0d7a6bbb57e">&#9670;&#160;</a></span>vmaBeginDefragmentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaBeginDefragmentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_defragmentation_info.html">VmaDefragmentationInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> *</td>          <td class="paramname"><span class="paramname"><em>pContext</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins defragmentation process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pInfo</td><td>Structure filled with parameters of defragmentation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pContext</td><td>Context object that must be passed to <a class="el" href="#ga59f01ca3d53d50b7cca9b442b77a3e87" title="Ends defragmentation process.">vmaEndDefragmentation()</a> to finish defragmentation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>VK_SUCCESS</code> if defragmentation can begin.</li>
<li><code>VK_ERROR_FEATURE_NOT_PRESENT</code> if defragmentation is not supported.</li>
</ul>
</dd></dl>
<p>For more information about defragmentation, see documentation chapter: <a class="el" href="defragmentation.html">Defragmentation</a>. </p>

</div>
</div>
<a id="ga980d7da2ce3b1fd5c8b8476bc362cc00" name="ga980d7da2ce3b1fd5c8b8476bc362cc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga980d7da2ce3b1fd5c8b8476bc362cc00">&#9670;&#160;</a></span>vmaBeginDefragmentationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaBeginDefragmentationPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a></td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pPassInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts single defragmentation pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>Context object that has been created by <a class="el" href="#gac3335566858b45541fa9c0d7a6bbb57e" title="Begins defragmentation process.">vmaBeginDefragmentation()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pPassInfo</td><td>Computed information for current pass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><code>VK_SUCCESS</code> if no more moves are possible. Then you can omit call to <a class="el" href="#gaded05a445742a00718ee766144c5c226" title="Ends single defragmentation pass.">vmaEndDefragmentationPass()</a> and simply end whole defragmentation.</li>
<li><code>VK_INCOMPLETE</code> if there are pending moves returned in <code>pPassInfo</code>. You need to perform them, call <a class="el" href="#gaded05a445742a00718ee766144c5c226" title="Ends single defragmentation pass.">vmaEndDefragmentationPass()</a>, and then preferably try another pass with <a class="el" href="#ga980d7da2ce3b1fd5c8b8476bc362cc00" title="Starts single defragmentation pass.">vmaBeginDefragmentationPass()</a>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6b0929b914b60cf2d45cac4bf3547470" name="ga6b0929b914b60cf2d45cac4bf3547470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b0929b914b60cf2d45cac4bf3547470">&#9670;&#160;</a></span>vmaBindBufferMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaBindBufferMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds buffer to allocation. </p>
<p>Binds specified buffer to region of memory represented by specified allocation. Gets <code>VkDeviceMemory</code> handle and offset from the allocation. If you want to create a buffer, allocate memory for it and bind them together separately, you should use this function for binding instead of standard <code>vkBindBufferMemory()</code>, because it ensures proper synchronization so that when a <code>VkDeviceMemory</code> object is used by multiple allocations, calls to <code>vkBind*Memory()</code> or <code>vkMapMemory()</code> won't happen from multiple threads simultaneously (which is illegal in Vulkan).</p>
<p>It is recommended to use function <a class="el" href="#gac72ee55598617e8eecca384e746bab51" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a> instead of this one. </p>

</div>
</div>
<a id="ga861f4f27189a7d11ab9d9eedc825cb6b" name="ga861f4f27189a7d11ab9d9eedc825cb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga861f4f27189a7d11ab9d9eedc825cb6b">&#9670;&#160;</a></span>vmaBindBufferMemory2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaBindBufferMemory2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize</td>          <td class="paramname"><span class="paramname"><em>allocationLocalOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *(VkBindBufferMemoryInfoKHR)</td>          <td class="paramname"><span class="paramname"><em>pNext</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds buffer to allocation with additional parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramname">allocation</td><td></td></tr>
    <tr><td class="paramname">allocationLocalOffset</td><td>Additional offset to be added while binding, relative to the beginning of the <code>allocation</code>. Normally it should be 0. </td></tr>
    <tr><td class="paramname">buffer</td><td></td></tr>
    <tr><td class="paramname">pNext</td><td>A chain of structures to be attached to <code>VkBindBufferMemoryInfoKHR</code> structure used internally. Normally it should be null.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is similar to <a class="el" href="#ga6b0929b914b60cf2d45cac4bf3547470" title="Binds buffer to allocation.">vmaBindBufferMemory()</a>, but it provides additional parameters.</p>
<p>If <code>pNext</code> is not null, <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a> object must have been created with <a class="el" href="group__group__init.html#gga4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</a> flag or with <a class="el" href="struct_vma_allocator_create_info.html#ae0ffc55139b54520a6bb704b29ffc285" title="Optional. Vulkan version that the application uses.">VmaAllocatorCreateInfo::vulkanApiVersion</a> <code>&gt;= VK_API_VERSION_1_1</code>. Otherwise the call fails. </p>

</div>
</div>
<a id="ga3d3ca45799923aa5d138e9e5f9eb2da5" name="ga3d3ca45799923aa5d138e9e5f9eb2da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d3ca45799923aa5d138e9e5f9eb2da5">&#9670;&#160;</a></span>vmaBindImageMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaBindImageMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage</td>          <td class="paramname"><span class="paramname"><em>image</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds image to allocation. </p>
<p>Binds specified image to region of memory represented by specified allocation. Gets <code>VkDeviceMemory</code> handle and offset from the allocation. If you want to create an image, allocate memory for it and bind them together separately, you should use this function for binding instead of standard <code>vkBindImageMemory()</code>, because it ensures proper synchronization so that when a <code>VkDeviceMemory</code> object is used by multiple allocations, calls to <code>vkBind*Memory()</code> or <code>vkMapMemory()</code> won't happen from multiple threads simultaneously (which is illegal in Vulkan).</p>
<p>It is recommended to use function <a class="el" href="#ga02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a> instead of this one. </p>

</div>
</div>
<a id="ga5f3502dd7d38b53fb1533ea3921d038d" name="ga5f3502dd7d38b53fb1533ea3921d038d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f3502dd7d38b53fb1533ea3921d038d">&#9670;&#160;</a></span>vmaBindImageMemory2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaBindImageMemory2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize</td>          <td class="paramname"><span class="paramname"><em>allocationLocalOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage</td>          <td class="paramname"><span class="paramname"><em>image</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *(VkBindImageMemoryInfoKHR)</td>          <td class="paramname"><span class="paramname"><em>pNext</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds image to allocation with additional parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramname">allocation</td><td></td></tr>
    <tr><td class="paramname">allocationLocalOffset</td><td>Additional offset to be added while binding, relative to the beginning of the <code>allocation</code>. Normally it should be 0. </td></tr>
    <tr><td class="paramname">image</td><td></td></tr>
    <tr><td class="paramname">pNext</td><td>A chain of structures to be attached to <code>VkBindImageMemoryInfoKHR</code> structure used internally. Normally it should be null.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is similar to <a class="el" href="#ga3d3ca45799923aa5d138e9e5f9eb2da5" title="Binds image to allocation.">vmaBindImageMemory()</a>, but it provides additional parameters.</p>
<p>If <code>pNext</code> is not null, <a class="el" href="struct_vma_allocator.html" title="Represents main object of this library initialized.">VmaAllocator</a> object must have been created with <a class="el" href="group__group__init.html#gga4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</a> flag or with <a class="el" href="struct_vma_allocator_create_info.html#ae0ffc55139b54520a6bb704b29ffc285" title="Optional. Vulkan version that the application uses.">VmaAllocatorCreateInfo::vulkanApiVersion</a> <code>&gt;= VK_API_VERSION_1_1</code>. Otherwise the call fails. </p>

</div>
</div>
<a id="ga49329a7f030dafcf82f7b73334c22e98" name="ga49329a7f030dafcf82f7b73334c22e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49329a7f030dafcf82f7b73334c22e98">&#9670;&#160;</a></span>vmaCheckCorruption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCheckCorruption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>memoryTypeBits</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramname">memoryTypeBits</td><td>Bit mask, where each bit set means that a memory type with that index should be checked.</td></tr>
  </table>
  </dd>
</dl>
<p>Corruption detection is enabled only when <code>VMA_DEBUG_DETECT_CORRUPTION</code> macro is defined to nonzero, <code>VMA_DEBUG_MARGIN</code> is defined to nonzero and only for memory types that are <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>. For more information, see <a class="el" href="debugging_memory_usage.html#debugging_memory_usage_corruption_detection">Corruption detection</a>.</p>
<p>Possible return values:</p>
<ul>
<li><code>VK_ERROR_FEATURE_NOT_PRESENT</code> - corruption detection is not enabled for any of specified memory types.</li>
<li><code>VK_SUCCESS</code> - corruption detection has been performed and succeeded.</li>
<li><code>VK_ERROR_UNKNOWN</code> - corruption detection has been performed and found memory corruptions around one of the allocations. <code>VMA_ASSERT</code> is also fired in that case.</li>
<li>Other value: Error returned by Vulkan, e.g. memory mapping failure. </li>
</ul>

</div>
</div>
<a id="gad535935619c7a549bf837e1bb0068f89" name="gad535935619c7a549bf837e1bb0068f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad535935619c7a549bf837e1bb0068f89">&#9670;&#160;</a></span>vmaCheckPoolCorruption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCheckPoolCorruption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool.html">VmaPool</a></td>          <td class="paramname"><span class="paramname"><em>pool</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks magic number in margins around all allocations in given memory pool in search for corruptions. </p>
<p>Corruption detection is enabled only when <code>VMA_DEBUG_DETECT_CORRUPTION</code> macro is defined to nonzero, <code>VMA_DEBUG_MARGIN</code> is defined to nonzero and the pool is created in memory type that is <code>HOST_VISIBLE</code> and <code>HOST_COHERENT</code>. For more information, see <a class="el" href="debugging_memory_usage.html#debugging_memory_usage_corruption_detection">Corruption detection</a>.</p>
<p>Possible return values:</p>
<ul>
<li><code>VK_ERROR_FEATURE_NOT_PRESENT</code> - corruption detection is not enabled for specified pool.</li>
<li><code>VK_SUCCESS</code> - corruption detection has been performed and succeeded.</li>
<li><code>VK_ERROR_UNKNOWN</code> - corruption detection has been performed and found memory corruptions around one of the allocations. <code>VMA_ASSERT</code> is also fired in that case.</li>
<li>Other value: Error returned by Vulkan, e.g. memory mapping failure. </li>
</ul>

</div>
</div>
<a id="gaac883dd38863944335071213b9ae8477" name="gaac883dd38863944335071213b9ae8477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac883dd38863944335071213b9ae8477">&#9670;&#160;</a></span>vmaCopyAllocationToMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCopyAllocationToMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>srcAllocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize</td>          <td class="paramname"><span class="paramname"><em>srcAllocationLocalOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>pDstHostPointer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidates memory in the host caches if needed, maps the allocation temporarily if needed, and copies data from it to a specified host pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramname">srcAllocation</td><td>Handle to the allocation that becomes source of the copy. </td></tr>
    <tr><td class="paramname">srcAllocationLocalOffset</td><td>Offset within <code>srcAllocation</code> where to read copied data, in bytes. </td></tr>
    <tr><td class="paramname">pDstHostPointer</td><td>Pointer to the host memory that become destination of the copy. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a convenience function that allows to copy data from an allocation to a host pointer easily. Same behavior can be achieved by calling <a class="el" href="#gaaa8412919139ef413a4215ac6a290fae" title="Invalidates memory of given allocation.">vmaInvalidateAllocation()</a>, <a class="el" href="#gad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>, <code>memcpy()</code>, <a class="el" href="#ga9bc268595cb33f6ec4d519cfce81ff45" title="Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().">vmaUnmapMemory()</a>.</p>
<p>This function should be called only for allocations created in a memory type that has <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code> flag. It can be ensured e.g. by using <a class="el" href="#ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e">VMA_MEMORY_USAGE_AUTO</a> and <a class="el" href="#ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</a>. Otherwise, the function may fail and generate a Validation Layers error. It may also work very slowly when reading from an uncached memory.</p>
<p><code>srcAllocationLocalOffset</code> is relative to the contents of given <code>srcAllocation</code>. If you mean whole allocation, you should pass 0. Do not pass allocation's offset within device memory block as this parameter! </p>

</div>
</div>
<a id="ga11731ec58a3a43a22bb925e0780ef405" name="ga11731ec58a3a43a22bb925e0780ef405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11731ec58a3a43a22bb925e0780ef405">&#9670;&#160;</a></span>vmaCopyMemoryToAllocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCopyMemoryToAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>pSrcHostPointer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>dstAllocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize</td>          <td class="paramname"><span class="paramname"><em>dstAllocationLocalOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps the allocation temporarily if needed, copies data from specified host pointer to it, and flushes the memory from the host caches if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramname">pSrcHostPointer</td><td>Pointer to the host data that become source of the copy. </td></tr>
    <tr><td class="paramname">dstAllocation</td><td>Handle to the allocation that becomes destination of the copy. </td></tr>
    <tr><td class="paramname">dstAllocationLocalOffset</td><td>Offset within <code>dstAllocation</code> where to write copied data, in bytes. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a convenience function that allows to copy data from a host pointer to an allocation easily. Same behavior can be achieved by calling <a class="el" href="#gad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>, <code>memcpy()</code>, <a class="el" href="#ga9bc268595cb33f6ec4d519cfce81ff45" title="Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().">vmaUnmapMemory()</a>, <a class="el" href="#ga30c37c1eec6025f397be41644f48490f" title="Flushes memory of given allocation.">vmaFlushAllocation()</a>.</p>
<p>This function can be called only for allocations created in a memory type that has <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> flag. It can be ensured e.g. by using <a class="el" href="#ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e">VMA_MEMORY_USAGE_AUTO</a> and <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</a> or <a class="el" href="#ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</a>. Otherwise, the function will fail and generate a Validation Layers error.</p>
<p><code>dstAllocationLocalOffset</code> is relative to the contents of given <code>dstAllocation</code>. If you mean whole allocation, you should pass 0. Do not pass allocation's offset within device memory block this parameter! </p>

</div>
</div>
<a id="ga60d5d4803e3c82505a2bfddb929adb03" name="ga60d5d4803e3c82505a2bfddb929adb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60d5d4803e3c82505a2bfddb929adb03">&#9670;&#160;</a></span>vmaCreateAliasingBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCreateAliasingBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkBufferCreateInfo *</td>          <td class="paramname"><span class="paramname"><em>pBufferCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer *</td>          <td class="paramname"><span class="paramname"><em>pBuffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <code>VkBuffer</code>, binds already created memory for it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocation</td><td>Allocation that provides memory to be used for binding new buffer to it. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pBufferCreateInfo</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pBuffer</td><td>Buffer that was created.</td></tr>
  </table>
  </dd>
</dl>
<p>This function automatically:</p>
<ol type="1">
<li>Creates buffer.</li>
<li>Binds the buffer with the supplied memory.</li>
</ol>
<p>If any of these operations fail, buffer is not created, returned value is negative error code and <code>*pBuffer</code> is null.</p>
<p>If the function succeeded, you must destroy the buffer when you no longer need it using <code>vkDestroyBuffer()</code>. If you want to also destroy the corresponding allocation you can use convenience function <a class="el" href="#ga0d9f4e4ba5bf9aab1f1c746387753d77" title="Destroys Vulkan buffer and frees allocated memory.">vmaDestroyBuffer()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>There is a new version of this function augmented with parameter <code>allocationLocalOffset</code> - see <a class="el" href="#gaf0cf014344213e117bd9f9cf5f928122" title="Creates a new VkBuffer, binds already created memory for it.">vmaCreateAliasingBuffer2()</a>. </dd></dl>

</div>
</div>
<a id="gaf0cf014344213e117bd9f9cf5f928122" name="gaf0cf014344213e117bd9f9cf5f928122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0cf014344213e117bd9f9cf5f928122">&#9670;&#160;</a></span>vmaCreateAliasingBuffer2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCreateAliasingBuffer2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize</td>          <td class="paramname"><span class="paramname"><em>allocationLocalOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkBufferCreateInfo *</td>          <td class="paramname"><span class="paramname"><em>pBufferCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer *</td>          <td class="paramname"><span class="paramname"><em>pBuffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <code>VkBuffer</code>, binds already created memory for it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocation</td><td>Allocation that provides memory to be used for binding new buffer to it. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allocationLocalOffset</td><td>Additional offset to be added while binding, relative to the beginning of the allocation. Normally it should be 0. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pBufferCreateInfo</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pBuffer</td><td>Buffer that was created.</td></tr>
  </table>
  </dd>
</dl>
<p>This function automatically:</p>
<ol type="1">
<li>Creates buffer.</li>
<li>Binds the buffer with the supplied memory.</li>
</ol>
<p>If any of these operations fail, buffer is not created, returned value is negative error code and <code>*pBuffer</code> is null.</p>
<p>If the function succeeded, you must destroy the buffer when you no longer need it using <code>vkDestroyBuffer()</code>. If you want to also destroy the corresponding allocation you can use convenience function <a class="el" href="#ga0d9f4e4ba5bf9aab1f1c746387753d77" title="Destroys Vulkan buffer and frees allocated memory.">vmaDestroyBuffer()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This is a new version of the function augmented with parameter <code>allocationLocalOffset</code>. </dd></dl>

</div>
</div>
<a id="gaebc4db1f94b53dba2338b4c0fd80d0dc" name="gaebc4db1f94b53dba2338b4c0fd80d0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebc4db1f94b53dba2338b4c0fd80d0dc">&#9670;&#160;</a></span>vmaCreateAliasingImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCreateAliasingImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkImageCreateInfo *</td>          <td class="paramname"><span class="paramname"><em>pImageCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage *</td>          <td class="paramname"><span class="paramname"><em>pImage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function similar to <a class="el" href="#ga60d5d4803e3c82505a2bfddb929adb03" title="Creates a new VkBuffer, binds already created memory for it.">vmaCreateAliasingBuffer()</a> but for images. </p>

</div>
</div>
<a id="ga69ac829f5bb0737449fa92c2d971f1bb" name="ga69ac829f5bb0737449fa92c2d971f1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69ac829f5bb0737449fa92c2d971f1bb">&#9670;&#160;</a></span>vmaCreateAliasingImage2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCreateAliasingImage2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize</td>          <td class="paramname"><span class="paramname"><em>allocationLocalOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkImageCreateInfo *</td>          <td class="paramname"><span class="paramname"><em>pImageCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage *</td>          <td class="paramname"><span class="paramname"><em>pImage</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function similar to <a class="el" href="#gaf0cf014344213e117bd9f9cf5f928122" title="Creates a new VkBuffer, binds already created memory for it.">vmaCreateAliasingBuffer2()</a> but for images. </p>

</div>
</div>
<a id="gac72ee55598617e8eecca384e746bab51" name="gac72ee55598617e8eecca384e746bab51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac72ee55598617e8eecca384e746bab51">&#9670;&#160;</a></span>vmaCreateBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCreateBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkBufferCreateInfo *</td>          <td class="paramname"><span class="paramname"><em>pBufferCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocationCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer *</td>          <td class="paramname"><span class="paramname"><em>pBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocationInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <code>VkBuffer</code>, allocates and binds memory for it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pBufferCreateInfo</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pAllocationCreateInfo</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pBuffer</td><td>Buffer that was created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocation</td><td>Allocation that was created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAllocationInfo</td><td>Optional. Information about allocated memory. It can be later fetched using function <a class="el" href="#ga86dd08aba8633bfa4ad0df2e76481d8b" title="Returns current information about specified allocation.">vmaGetAllocationInfo()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function automatically:</p>
<ol type="1">
<li>Creates buffer.</li>
<li>Allocates appropriate memory for it.</li>
<li>Binds the buffer with the memory.</li>
</ol>
<p>If any of these operations fail, buffer and allocation are not created, returned value is negative error code, <code>*pBuffer</code> and <code>*pAllocation</code> are null.</p>
<p>If the function succeeded, you must destroy both buffer and allocation when you no longer need them using either convenience function <a class="el" href="#ga0d9f4e4ba5bf9aab1f1c746387753d77" title="Destroys Vulkan buffer and frees allocated memory.">vmaDestroyBuffer()</a> or separately, using <code>vkDestroyBuffer()</code> and <a class="el" href="#ga5fea5518972ae9094b1526cbcb19b05f" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a>.</p>
<p>If <a class="el" href="group__group__init.html#gga4f87c9100d154a65a4ad495f7763cf7cace7da7cc6e71a625dfa763c55a597878" title="Enables usage of VK_KHR_dedicated_allocation extension.">VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</a> flag was used, VK_KHR_dedicated_allocation extension is used internally to query driver whether it requires or prefers the new buffer to have dedicated allocation. If yes, and if dedicated allocation is possible (<a class="el" href="#ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" title="Set this flag to only try to allocate from existing VkDeviceMemory blocks and never create new such b...">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</a> is not used), it creates dedicated allocation for this buffer, just like when using <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" title="Set this flag if the allocation should have its own memory block.">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function creates a new <code>VkBuffer</code>. Sub-allocation of parts of one large buffer, although recommended as a good practice, is out of scope of this library and could be implemented by the user as a higher-level logic on top of VMA. </dd></dl>

</div>
</div>
<a id="gaa06a690013a0d01e60894ac378083834" name="gaa06a690013a0d01e60894ac378083834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa06a690013a0d01e60894ac378083834">&#9670;&#160;</a></span>vmaCreateBufferWithAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCreateBufferWithAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkBufferCreateInfo *</td>          <td class="paramname"><span class="paramname"><em>pBufferCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocationCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize</td>          <td class="paramname"><span class="paramname"><em>minAlignment</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer *</td>          <td class="paramname"><span class="paramname"><em>pBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocationInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a buffer with additional minimum alignment. </p>
<p>Similar to <a class="el" href="#gac72ee55598617e8eecca384e746bab51" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a> but provides additional parameter <code>minAlignment</code> which allows to specify custom, minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g. for interop with OpenGL. </p>

</div>
</div>
<a id="ga02a94f25679275851a53e82eacbcfc73" name="ga02a94f25679275851a53e82eacbcfc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02a94f25679275851a53e82eacbcfc73">&#9670;&#160;</a></span>vmaCreateImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCreateImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkImageCreateInfo *</td>          <td class="paramname"><span class="paramname"><em>pImageCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocationCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage *</td>          <td class="paramname"><span class="paramname"><em>pImage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocationInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function similar to <a class="el" href="#gac72ee55598617e8eecca384e746bab51" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>. </p>

</div>
</div>
<a id="ga5c8770ded7c59c8caac6de0c2cb00b50" name="ga5c8770ded7c59c8caac6de0c2cb00b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c8770ded7c59c8caac6de0c2cb00b50">&#9670;&#160;</a></span>vmaCreatePool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaCreatePool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_pool_create_info.html">VmaPoolCreateInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool.html">VmaPool</a> *</td>          <td class="paramname"><span class="paramname"><em>pPool</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates Vulkan device memory and creates <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pCreateInfo</td><td>Parameters of pool to create. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pPool</td><td>Handle to created pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d9f4e4ba5bf9aab1f1c746387753d77" name="ga0d9f4e4ba5bf9aab1f1c746387753d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d9f4e4ba5bf9aab1f1c746387753d77">&#9670;&#160;</a></span>vmaDestroyBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaDestroyBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBuffer</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys Vulkan buffer and frees allocated memory. </p>
<p>This is just a convenience function equivalent to:</p>
<div class="fragment"><div class="line">vkDestroyBuffer(device, buffer, allocationCallbacks);</div>
<div class="line"><a class="code hl_function" href="#ga5fea5518972ae9094b1526cbcb19b05f">vmaFreeMemory</a>(allocator, allocation);</div>
<div class="ttc" id="agroup__group__alloc_html_ga5fea5518972ae9094b1526cbcb19b05f"><div class="ttname"><a href="#ga5fea5518972ae9094b1526cbcb19b05f">vmaFreeMemory</a></div><div class="ttdeci">void vmaFreeMemory(VmaAllocator allocator, const VmaAllocation allocation)</div><div class="ttdoc">Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...</div></div>
</div><!-- fragment --><p>It is safe to pass null as buffer and/or allocation. </p>

</div>
</div>
<a id="gae50d2cb3b4a3bfd4dd40987234e50e7e" name="gae50d2cb3b4a3bfd4dd40987234e50e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae50d2cb3b4a3bfd4dd40987234e50e7e">&#9670;&#160;</a></span>vmaDestroyImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaDestroyImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImage</td>          <td class="paramname"><span class="paramname"><em>image</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys Vulkan image and frees allocated memory. </p>
<p>This is just a convenience function equivalent to:</p>
<div class="fragment"><div class="line">vkDestroyImage(device, image, allocationCallbacks);</div>
<div class="line"><a class="code hl_function" href="#ga5fea5518972ae9094b1526cbcb19b05f">vmaFreeMemory</a>(allocator, allocation);</div>
</div><!-- fragment --><p>It is safe to pass null as image and/or allocation. </p>

</div>
</div>
<a id="ga5485779c8f1948238fc4e92232fa65e1" name="ga5485779c8f1948238fc4e92232fa65e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5485779c8f1948238fc4e92232fa65e1">&#9670;&#160;</a></span>vmaDestroyPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaDestroyPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool.html">VmaPool</a></td>          <td class="paramname"><span class="paramname"><em>pool</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys <a class="el" href="struct_vma_pool.html" title="Represents custom memory pool.">VmaPool</a> object and frees Vulkan device memory. </p>

</div>
</div>
<a id="ga59f01ca3d53d50b7cca9b442b77a3e87" name="ga59f01ca3d53d50b7cca9b442b77a3e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59f01ca3d53d50b7cca9b442b77a3e87">&#9670;&#160;</a></span>vmaEndDefragmentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaEndDefragmentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a></td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_stats.html">VmaDefragmentationStats</a> *</td>          <td class="paramname"><span class="paramname"><em>pStats</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ends defragmentation process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>Context object that has been created by <a class="el" href="#gac3335566858b45541fa9c0d7a6bbb57e" title="Begins defragmentation process.">vmaBeginDefragmentation()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pStats</td><td>Optional stats for the defragmentation. Can be null.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this function to finish defragmentation started by <a class="el" href="#gac3335566858b45541fa9c0d7a6bbb57e" title="Begins defragmentation process.">vmaBeginDefragmentation()</a>. </p>

</div>
</div>
<a id="gaded05a445742a00718ee766144c5c226" name="gaded05a445742a00718ee766144c5c226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaded05a445742a00718ee766144c5c226">&#9670;&#160;</a></span>vmaEndDefragmentationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaEndDefragmentationPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a></td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_defragmentation_pass_move_info.html">VmaDefragmentationPassMoveInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pPassInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ends single defragmentation pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>Allocator object. </td></tr>
    <tr><td class="paramname">context</td><td>Context object that has been created by <a class="el" href="#gac3335566858b45541fa9c0d7a6bbb57e" title="Begins defragmentation process.">vmaBeginDefragmentation()</a>. </td></tr>
    <tr><td class="paramname">pPassInfo</td><td>Computed information for current pass filled by <a class="el" href="#ga980d7da2ce3b1fd5c8b8476bc362cc00" title="Starts single defragmentation pass.">vmaBeginDefragmentationPass()</a> and possibly modified by you.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns <code>VK_SUCCESS</code> if no more moves are possible or <code>VK_INCOMPLETE</code> if more defragmentations are possible.</p>
<p>Ends incremental defragmentation pass and commits all defragmentation moves from <code>pPassInfo</code>. After this call:</p>
<ul>
<li>Allocations at <code>pPassInfo[i].srcAllocation</code> that had <code>pPassInfo[i].operation ==</code> <a class="el" href="#ggada9e3861caf96f08894b0bcc160ec257ad4a06ac46c4cb1c67b0ebc1edfab9f18" title="Buffer/image has been recreated at dstTmpAllocation, data has been copied, old buffer/image has been ...">VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY</a> (which is the default) will be pointing to the new destination place.</li>
<li>Allocation at <code>pPassInfo[i].srcAllocation</code> that had <code>pPassInfo[i].operation ==</code> <a class="el" href="#ggada9e3861caf96f08894b0bcc160ec257a9786f8492a9be2c03bd26395e352ab85" title="Set this value if you decide to abandon the allocation and you destroyed the buffer/image....">VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY</a> will be freed.</li>
</ul>
<p>If no more moves are possible you can end whole defragmentation. </p>

</div>
</div>
<a id="gaef15a94b58fbcb0fe706d5720e84a74a" name="gaef15a94b58fbcb0fe706d5720e84a74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef15a94b58fbcb0fe706d5720e84a74a">&#9670;&#160;</a></span>vmaFindMemoryTypeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaFindMemoryTypeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>memoryTypeBits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocationCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pMemoryTypeIndex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helps to find memoryTypeIndex, given memoryTypeBits and <a class="el" href="struct_vma_allocation_create_info.html" title="Parameters of new VmaAllocation.">VmaAllocationCreateInfo</a>. </p>
<p>This algorithm tries to find a memory type that:</p>
<ul>
<li>Is allowed by memoryTypeBits.</li>
<li>Contains all the flags from pAllocationCreateInfo-&gt;requiredFlags.</li>
<li>Matches intended usage.</li>
<li>Has as many flags from pAllocationCreateInfo-&gt;preferredFlags as possible.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result from this function or any other allocating function probably means that your device doesn't support any memory type with requested features for the specific type of resource you want to use it for. Please check parameters of your resource, like image layout (OPTIMAL versus LINEAR) or mip level count. </dd></dl>

</div>
</div>
<a id="gae790ab9ffaf7667fb8f62523e6897888" name="gae790ab9ffaf7667fb8f62523e6897888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae790ab9ffaf7667fb8f62523e6897888">&#9670;&#160;</a></span>vmaFindMemoryTypeIndexForBufferInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaFindMemoryTypeIndexForBufferInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkBufferCreateInfo *</td>          <td class="paramname"><span class="paramname"><em>pBufferCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocationCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pMemoryTypeIndex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helps to find memoryTypeIndex, given VkBufferCreateInfo and <a class="el" href="struct_vma_allocation_create_info.html" title="Parameters of new VmaAllocation.">VmaAllocationCreateInfo</a>. </p>
<p>It can be useful e.g. to determine value to be used as <a class="el" href="struct_vma_pool_create_info.html#a596fa76b685d3f1f688f84a709a5b319" title="Vulkan memory type index to allocate this pool from.">VmaPoolCreateInfo::memoryTypeIndex</a>. It internally creates a temporary, dummy buffer that never has memory bound. </p>

</div>
</div>
<a id="ga088da83d8eaf3ce9056d9ea0b981d472" name="ga088da83d8eaf3ce9056d9ea0b981d472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga088da83d8eaf3ce9056d9ea0b981d472">&#9670;&#160;</a></span>vmaFindMemoryTypeIndexForImageInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaFindMemoryTypeIndexForImageInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkImageCreateInfo *</td>          <td class="paramname"><span class="paramname"><em>pImageCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation_create_info.html">VmaAllocationCreateInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocationCreateInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pMemoryTypeIndex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helps to find memoryTypeIndex, given VkImageCreateInfo and <a class="el" href="struct_vma_allocation_create_info.html" title="Parameters of new VmaAllocation.">VmaAllocationCreateInfo</a>. </p>
<p>It can be useful e.g. to determine value to be used as <a class="el" href="struct_vma_pool_create_info.html#a596fa76b685d3f1f688f84a709a5b319" title="Vulkan memory type index to allocate this pool from.">VmaPoolCreateInfo::memoryTypeIndex</a>. It internally creates a temporary, dummy image that never has memory bound. </p>

</div>
</div>
<a id="ga30c37c1eec6025f397be41644f48490f" name="ga30c37c1eec6025f397be41644f48490f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30c37c1eec6025f397be41644f48490f">&#9670;&#160;</a></span>vmaFlushAllocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaFlushAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes memory of given allocation. </p>
<p>Calls <code>vkFlushMappedMemoryRanges()</code> for memory associated with given range of given allocation. It needs to be called after writing to a mapped memory for memory types that are not <code>HOST_COHERENT</code>. Unmap operation doesn't do that automatically.</p>
<ul>
<li><code>offset</code> must be relative to the beginning of allocation.</li>
<li><code>size</code> can be <code>VK_WHOLE_SIZE</code>. It means all memory from <code>offset</code> the the end of given allocation.</li>
<li><code>offset</code> and <code>size</code> don't have to be aligned. They are internally rounded down/up to multiply of <code>nonCoherentAtomSize</code>.</li>
<li>If <code>size</code> is 0, this call is ignored.</li>
<li>If memory type that the <code>allocation</code> belongs to is not <code>HOST_VISIBLE</code> or it is <code>HOST_COHERENT</code>, this call is ignored.</li>
</ul>
<p>Warning! <code>offset</code> and <code>size</code> are relative to the contents of given <code>allocation</code>. If you mean whole allocation, you can pass 0 and <code>VK_WHOLE_SIZE</code>, respectively. Do not pass allocation's offset as <code>offset</code>!!!</p>
<p>This function returns the <code>VkResult</code> from <code>vkFlushMappedMemoryRanges</code> if it is called, otherwise <code>VK_SUCCESS</code>. </p>

</div>
</div>
<a id="gac3dd00da721875ed99fa8a881922bdfc" name="gac3dd00da721875ed99fa8a881922bdfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3dd00da721875ed99fa8a881922bdfc">&#9670;&#160;</a></span>vmaFlushAllocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaFlushAllocations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>allocationCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *</td>          <td class="paramname"><span class="paramname"><em>allocations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize *</td>          <td class="paramname"><span class="paramname"><em>offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize *</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes memory of given set of allocations. </p>
<p>Calls <code>vkFlushMappedMemoryRanges()</code> for memory associated with given ranges of given allocations. For more information, see documentation of <a class="el" href="#ga30c37c1eec6025f397be41644f48490f" title="Flushes memory of given allocation.">vmaFlushAllocation()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramname">allocationCount</td><td></td></tr>
    <tr><td class="paramname">allocations</td><td></td></tr>
    <tr><td class="paramname">offsets</td><td>If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all offsets are zero. </td></tr>
    <tr><td class="paramname">sizes</td><td>If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means <code>VK_WHOLE_SIZE</code> for all allocations.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the <code>VkResult</code> from <code>vkFlushMappedMemoryRanges</code> if it is called, otherwise <code>VK_SUCCESS</code>. </p>

</div>
</div>
<a id="ga5fea5518972ae9094b1526cbcb19b05f" name="ga5fea5518972ae9094b1526cbcb19b05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fea5518972ae9094b1526cbcb19b05f">&#9670;&#160;</a></span>vmaFreeMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaFreeMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory previously allocated using <a class="el" href="#gabf28077dbf82d0908b8acbe8ee8dd9b8" title="General purpose memory allocation.">vmaAllocateMemory()</a>, <a class="el" href="#ga7fdf64415b6c3d83c454f28d2c53df7b" title="Allocates memory suitable for given VkBuffer.">vmaAllocateMemoryForBuffer()</a>, or <a class="el" href="#ga0faa3f9e5fb233d29d1e00390650febb" title="Allocates memory suitable for given VkImage.">vmaAllocateMemoryForImage()</a>. </p>
<p>Passing <code>VK_NULL_HANDLE</code> as <code>allocation</code> is valid. Such function call is just skipped. </p>

</div>
</div>
<a id="ga834b1e4aef395c0a1d56a28e69a4a17e" name="ga834b1e4aef395c0a1d56a28e69a4a17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga834b1e4aef395c0a1d56a28e69a4a17e">&#9670;&#160;</a></span>vmaFreeMemoryPages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaFreeMemoryPages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>allocationCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocations</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory and destroys multiple allocations. </p>
<p>Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding. It is just a general purpose function to free memory and destroy allocations made using e.g. <a class="el" href="#gabf28077dbf82d0908b8acbe8ee8dd9b8" title="General purpose memory allocation.">vmaAllocateMemory()</a>, <a class="el" href="#gad37e82e492b3de38fc3f4cffd9ad0ae1" title="General purpose memory allocation for multiple allocation objects at once.">vmaAllocateMemoryPages()</a> and other functions. It may be internally optimized to be more efficient than calling <a class="el" href="#ga5fea5518972ae9094b1526cbcb19b05f" title="Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(),...">vmaFreeMemory()</a> <code>allocationCount</code> times.</p>
<p>Allocations in <code>pAllocations</code> array can come from any memory pools and types. Passing <code>VK_NULL_HANDLE</code> as elements of <code>pAllocations</code> array is valid. Such entries are just skipped. </p>

</div>
</div>
<a id="ga86dd08aba8633bfa4ad0df2e76481d8b" name="ga86dd08aba8633bfa4ad0df2e76481d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86dd08aba8633bfa4ad0df2e76481d8b">&#9670;&#160;</a></span>vmaGetAllocationInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaGetAllocationInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocationInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current information about specified allocation. </p>
<p>Current parameters of given allocation are returned in <code>pAllocationInfo</code>.</p>
<p>Although this function doesn't lock any mutex, so it should be quite efficient, you should avoid calling it too often. You can retrieve same <a class="el" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> structure while creating your resource, from function <a class="el" href="#gac72ee55598617e8eecca384e746bab51" title="Creates a new VkBuffer, allocates and binds memory for it.">vmaCreateBuffer()</a>, <a class="el" href="#ga02a94f25679275851a53e82eacbcfc73" title="Function similar to vmaCreateBuffer().">vmaCreateImage()</a>. You can remember it if you are sure parameters don't change (e.g. due to defragmentation).</p>
<p>There is also a new function <a class="el" href="#ga1405cf3eae2fd1305d645879173031a0" title="Returns extended information about specified allocation.">vmaGetAllocationInfo2()</a> that offers extended information about the allocation, returned using new structure <a class="el" href="struct_vma_allocation_info2.html" title="Extended parameters of a VmaAllocation object that can be retrieved using function vmaGetAllocationIn...">VmaAllocationInfo2</a>. </p>

</div>
</div>
<a id="ga1405cf3eae2fd1305d645879173031a0" name="ga1405cf3eae2fd1305d645879173031a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1405cf3eae2fd1305d645879173031a0">&#9670;&#160;</a></span>vmaGetAllocationInfo2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaGetAllocationInfo2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation_info2.html">VmaAllocationInfo2</a> *</td>          <td class="paramname"><span class="paramname"><em>pAllocationInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns extended information about specified allocation. </p>
<p>Current parameters of given allocation are returned in <code>pAllocationInfo</code>. Extended parameters in structure <a class="el" href="struct_vma_allocation_info2.html" title="Extended parameters of a VmaAllocation object that can be retrieved using function vmaGetAllocationIn...">VmaAllocationInfo2</a> include memory block size and a flag telling whether the allocation has dedicated memory. It can be useful e.g. for interop with OpenGL. </p>

</div>
</div>
<a id="ga571e87dd38e552249b56b1b0b982fad1" name="ga571e87dd38e552249b56b1b0b982fad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga571e87dd38e552249b56b1b0b982fad1">&#9670;&#160;</a></span>vmaGetAllocationMemoryProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaGetAllocationMemoryProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkMemoryPropertyFlags *</td>          <td class="paramname"><span class="paramname"><em>pFlags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an allocation, returns Property Flags of its memory type. </p>
<p>This is just a convenience function. Same information can be obtained using <a class="el" href="#ga86dd08aba8633bfa4ad0df2e76481d8b" title="Returns current information about specified allocation.">vmaGetAllocationInfo()</a> + <a class="el" href="group__group__init.html#gab88db292a17974f911182543fda52d19">vmaGetMemoryProperties()</a>. </p>

</div>
</div>
<a id="ga8d327b7458d8cf426b84b5efba9bb9bf" name="ga8d327b7458d8cf426b84b5efba9bb9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d327b7458d8cf426b84b5efba9bb9bf">&#9670;&#160;</a></span>vmaGetMemoryWin32Handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaGetMemoryWin32Handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HANDLE</td>          <td class="paramname"><span class="paramname"><em>hTargetProcess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HANDLE *</td>          <td class="paramname"><span class="paramname"><em>pHandle</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an allocation, returns Win32 handle that may be imported by other processes or APIs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">hTargetProcess</td><td>Must be a valid handle to target process or null. If it's null, the function returns handle for the current process. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pHandle</td><td>Output parameter that returns the handle.</td></tr>
  </table>
  </dd>
</dl>
<p>The function fills <code>pHandle</code> with handle that can be used in target process. The handle is fetched using function <code>vkGetMemoryWin32HandleKHR</code>. When no longer needed, you must close it using:</p>
<div class="fragment"><div class="line">CloseHandle(handle);</div>
</div><!-- fragment --><p>You can close it any time, before or after destroying the allocation object. It is reference-counted internally by Windows.</p>
<p>Note the handle is returned for the entire <code>VkDeviceMemory</code> block that the allocation belongs to. If the allocation is sub-allocated from a larger block, you may need to consider the offset of the allocation (<a class="el" href="struct_vma_allocation_info.html#a4a3c732388dbdc7a23f9365b00825268" title="Offset in VkDeviceMemory object to the beginning of this allocation, in bytes. (deviceMemory,...">VmaAllocationInfo::offset</a>).</p>
<p>If the function fails with <code>VK_ERROR_FEATURE_NOT_PRESENT</code> error code, please double-check that <a class="el" href="struct_vma_vulkan_functions.html#af45d10a2b47971f4cf5bcacf1d331f86">VmaVulkanFunctions::vkGetMemoryWin32HandleKHR</a> function pointer is set, e.g. either by using <code>VMA_DYNAMIC_VULKAN_FUNCTIONS</code> or by manually passing it through <a class="el" href="struct_vma_allocator_create_info.html#a3dc197be3227da7338b1643f70db36bd" title="Pointers to Vulkan functions. Can be null.">VmaAllocatorCreateInfo::pVulkanFunctions</a>.</p>
<p>For more information, see chapter <a class="el" href="vk_khr_external_memory_win32.html">VK_KHR_external_memory_win32</a>. </p>

</div>
</div>
<a id="gaf09b4e4eafdbee812e8d73ddf960f030" name="gaf09b4e4eafdbee812e8d73ddf960f030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf09b4e4eafdbee812e8d73ddf960f030">&#9670;&#160;</a></span>vmaGetPoolName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaGetPoolName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool.html">VmaPool</a></td>          <td class="paramname"><span class="paramname"><em>pool</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>ppName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves name of a custom pool. </p>
<p>After the call <code>ppName</code> is either null or points to an internally-owned null-terminated string containing name of the pool that was previously set. The pointer becomes invalid when the pool is destroyed or its name is changed using <a class="el" href="#gadbae3a0b4ab078024462fc85c37f3b58" title="Sets name of a custom pool.">vmaSetPoolName()</a>. </p>

</div>
</div>
<a id="gaaa8412919139ef413a4215ac6a290fae" name="gaaa8412919139ef413a4215ac6a290fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa8412919139ef413a4215ac6a290fae">&#9670;&#160;</a></span>vmaInvalidateAllocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaInvalidateAllocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidates memory of given allocation. </p>
<p>Calls <code>vkInvalidateMappedMemoryRanges()</code> for memory associated with given range of given allocation. It needs to be called before reading from a mapped memory for memory types that are not <code>HOST_COHERENT</code>. Map operation doesn't do that automatically.</p>
<ul>
<li><code>offset</code> must be relative to the beginning of allocation.</li>
<li><code>size</code> can be <code>VK_WHOLE_SIZE</code>. It means all memory from <code>offset</code> the the end of given allocation.</li>
<li><code>offset</code> and <code>size</code> don't have to be aligned. They are internally rounded down/up to multiply of <code>nonCoherentAtomSize</code>.</li>
<li>If <code>size</code> is 0, this call is ignored.</li>
<li>If memory type that the <code>allocation</code> belongs to is not <code>HOST_VISIBLE</code> or it is <code>HOST_COHERENT</code>, this call is ignored.</li>
</ul>
<p>Warning! <code>offset</code> and <code>size</code> are relative to the contents of given <code>allocation</code>. If you mean whole allocation, you can pass 0 and <code>VK_WHOLE_SIZE</code>, respectively. Do not pass allocation's offset as <code>offset</code>!!!</p>
<p>This function returns the <code>VkResult</code> from <code>vkInvalidateMappedMemoryRanges</code> if it is called, otherwise <code>VK_SUCCESS</code>. </p>

</div>
</div>
<a id="gab25b558d75f7378ec944a1522fdcc3c5" name="gab25b558d75f7378ec944a1522fdcc3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab25b558d75f7378ec944a1522fdcc3c5">&#9670;&#160;</a></span>vmaInvalidateAllocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaInvalidateAllocations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>allocationCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_vma_allocation.html">VmaAllocation</a> *</td>          <td class="paramname"><span class="paramname"><em>allocations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize *</td>          <td class="paramname"><span class="paramname"><em>offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize *</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidates memory of given set of allocations. </p>
<p>Calls <code>vkInvalidateMappedMemoryRanges()</code> for memory associated with given ranges of given allocations. For more information, see documentation of <a class="el" href="#gaaa8412919139ef413a4215ac6a290fae" title="Invalidates memory of given allocation.">vmaInvalidateAllocation()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
    <tr><td class="paramname">allocationCount</td><td></td></tr>
    <tr><td class="paramname">allocations</td><td></td></tr>
    <tr><td class="paramname">offsets</td><td>If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all offsets are zero. </td></tr>
    <tr><td class="paramname">sizes</td><td>If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means <code>VK_WHOLE_SIZE</code> for all allocations.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the <code>VkResult</code> from <code>vkInvalidateMappedMemoryRanges</code> if it is called, otherwise <code>VK_SUCCESS</code>. </p>

</div>
</div>
<a id="gad5bd1243512d099706de88168992f069" name="gad5bd1243512d099706de88168992f069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5bd1243512d099706de88168992f069">&#9670;&#160;</a></span>vmaMapMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkResult vmaMapMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>ppData</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps memory represented by given allocation and returns pointer to it. </p>
<p>Maps memory represented by given allocation to make it accessible to CPU code. When succeeded, <code>*ppData</code> contains pointer to first byte of this memory.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the allocation is part of a bigger <code>VkDeviceMemory</code> block, returned pointer is correctly offsetted to the beginning of region assigned to this particular allocation. Unlike the result of <code>vkMapMemory</code>, it points to the allocation, not to the beginning of the whole block. You should not add <a class="el" href="struct_vma_allocation_info.html#a4a3c732388dbdc7a23f9365b00825268" title="Offset in VkDeviceMemory object to the beginning of this allocation, in bytes. (deviceMemory,...">VmaAllocationInfo::offset</a> to it!</dd></dl>
<p>Mapping is internally reference-counted and synchronized, so despite raw Vulkan function <code>vkMapMemory()</code> cannot be used to map same block of <code>VkDeviceMemory</code> multiple times simultaneously, it is safe to call this function on allocations assigned to the same memory block. Actual Vulkan memory will be mapped on first mapping and unmapped on last unmapping.</p>
<p>If the function succeeded, you must call <a class="el" href="#ga9bc268595cb33f6ec4d519cfce81ff45" title="Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().">vmaUnmapMemory()</a> to unmap the allocation when mapping is no longer needed or before freeing the allocation, at the latest.</p>
<p>It also safe to call this function multiple times on the same allocation. You must call <a class="el" href="#ga9bc268595cb33f6ec4d519cfce81ff45" title="Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().">vmaUnmapMemory()</a> same number of times as you called <a class="el" href="#gad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>.</p>
<p>It is also safe to call this function on allocation created with <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a> flag. Its memory stays mapped all the time. You must still call <a class="el" href="#ga9bc268595cb33f6ec4d519cfce81ff45" title="Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().">vmaUnmapMemory()</a> same number of times as you called <a class="el" href="#gad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>. You must not call <a class="el" href="#ga9bc268595cb33f6ec4d519cfce81ff45" title="Unmaps memory represented by given allocation, mapped previously using vmaMapMemory().">vmaUnmapMemory()</a> additional time to free the "0-th" mapping made automatically due to <a class="el" href="#ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" title="Set this flag to use a memory that will be persistently mapped and retrieve pointer to it.">VMA_ALLOCATION_CREATE_MAPPED_BIT</a> flag.</p>
<p>This function fails when used on allocation made in memory type that is not <code>HOST_VISIBLE</code>.</p>
<p>This function doesn't automatically flush or invalidate caches. If the allocation is made from a memory types that is not <code>HOST_COHERENT</code>, you also need to use <a class="el" href="#gaaa8412919139ef413a4215ac6a290fae" title="Invalidates memory of given allocation.">vmaInvalidateAllocation()</a> / <a class="el" href="#ga30c37c1eec6025f397be41644f48490f" title="Flushes memory of given allocation.">vmaFlushAllocation()</a>, as required by Vulkan specification. </p>

</div>
</div>
<a id="gabe02cbb0cd913b3f125958179f2020fc" name="gabe02cbb0cd913b3f125958179f2020fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe02cbb0cd913b3f125958179f2020fc">&#9670;&#160;</a></span>vmaSetAllocationName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaSetAllocationName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets pName in given allocation to new value. </p>
<p><code>pName</code> must be either null, or pointer to a null-terminated string. The function makes local copy of the string and sets it as allocation's <code>pName</code>. String passed as pName doesn't need to be valid for whole lifetime of the allocation - you can free it after this call. String previously pointed by allocation's <code>pName</code> is freed from memory. </p>

</div>
</div>
<a id="gaf9147d31ffc11d62fc187bde283ed14f" name="gaf9147d31ffc11d62fc187bde283ed14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9147d31ffc11d62fc187bde283ed14f">&#9670;&#160;</a></span>vmaSetAllocationUserData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaSetAllocationUserData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>pUserData</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets pUserData in given allocation to new value. </p>
<p>The value of pointer <code>pUserData</code> is copied to allocation's <code>pUserData</code>. It is opaque, so you can use it however you want - e.g. as a pointer, ordinal number or some handle to you own data. </p>

</div>
</div>
<a id="gadbae3a0b4ab078024462fc85c37f3b58" name="gadbae3a0b4ab078024462fc85c37f3b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbae3a0b4ab078024462fc85c37f3b58">&#9670;&#160;</a></span>vmaSetPoolName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaSetPoolName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_pool.html">VmaPool</a></td>          <td class="paramname"><span class="paramname"><em>pool</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets name of a custom pool. </p>
<p><code>pName</code> can be either null or pointer to a null-terminated string with new name for the pool. Function makes internal copy of the string, so it can be changed or freed immediately after this call. </p>

</div>
</div>
<a id="ga9bc268595cb33f6ec4d519cfce81ff45" name="ga9bc268595cb33f6ec4d519cfce81ff45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bc268595cb33f6ec4d519cfce81ff45">&#9670;&#160;</a></span>vmaUnmapMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmaUnmapMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_vma_allocator.html">VmaAllocator</a></td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_vma_allocation.html">VmaAllocation</a></td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmaps memory represented by given allocation, mapped previously using <a class="el" href="#gad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>. </p>
<p>For details, see description of <a class="el" href="#gad5bd1243512d099706de88168992f069" title="Maps memory represented by given allocation and returns pointer to it.">vmaMapMemory()</a>.</p>
<p>This function doesn't automatically flush or invalidate caches. If the allocation is made from a memory types that is not <code>HOST_COHERENT</code>, you also need to use <a class="el" href="#gaaa8412919139ef413a4215ac6a290fae" title="Invalidates memory of given allocation.">vmaInvalidateAllocation()</a> / <a class="el" href="#ga30c37c1eec6025f397be41644f48490f" title="Flushes memory of given allocation.">vmaFlushAllocation()</a>, as required by Vulkan specification. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
